* Rails
** 构造联合查询
def self.search(title, category_id, city_id)
    rel = scoped
    rel = rel.where('title    like ?', "%#{title}%") if(title)
    rel = rel.where('category_id = ?', category_id)  if(category_id)
    rel = rel.where('city_id     = ?', city_id)      if(city_id)
    rel
end

** 调用save方法时的callback顺序
before_validation
before_validation :on => :create
after_validation
after_validation  :on => :create
before_save
before_create
after_create
after_save
** callback方法之间的一些差别
- 参考: http://stackoverflow.com/questions/6422199/what-is-the-difference-between-after-create-and-after-save-and-when-to-use-w
- after_create only works once - just after the record is first created.
- after_save works every time you save the object - even if you're just updating it many years later
** cucumber
*** 搭建命令
rails generate cucumber:install --help
rails generate cucumber:install
bin/cucumber --i18n zh-CN
*** 关键词
| feature          | "功能"                      |
| background       | "背景"                      |
| scenario         | "场景", "剧本"               |
| scenario_outline | "场景大纲", "剧本大纲"        |
| examples         | "例子"                      |
| given            | "* ", "假如", "假设", "假定" |
| when             | "* ", "当"                  |
| then             | "* ", "那么"                |
| and              | "* ", "而且", "并且", "同时" |
| but              | "* ", "但是"                |
| given (code)     | "假如", "假设", "假定"       |
| when (code)      | "当"                        |
| then (code)      | "那么"                      |
| and (code)       | "而且", "并且", "同时"       |
| but (code)       | "但是"                      |

| feature          | "Feature", "Business Need", "Ability"   |
| background       | "Background"                            |
| scenario         | "Scenario"                              |
| scenario_outline | "Scenario Outline", "Scenario Template" |
| examples         | "Examples", "Scenarios"                 |
| given            | "* ", "Given "                          |
| when             | "* ", "When "                           |
| then             | "* ", "Then "                           |
| and              | "* ", "And "                            |
| but              | "* ", "But "                            |
| given (code)     | "Given"                                 |
| when (code)      | "When"                                  |
| then (code)      | "Then"                                  |
| and (code)       | "And"                                   |
| but (code)       | "But"                                   |

*** 场景大纲
Scenario Outline: eating
  Given there are <start> cucumbers
  When I eat <eat> cucumbers
  Then I should have <left> cucumbers

  Examples:
    | start | eat | left |
    |  12   |  5  |  7   |
    |  20   |  5  |  15  |

参考:
https://github.com/cucumber/cucumber/wiki/Scenario-Outlines

*** Tags
cucumber --tags @debug
参考:
ohttps://github.com/cucumber/cucumber/wiki/Tags   

*** 错误记录
使用"功能"这个关键词会导致Gherkin::Lexer::LexingError错误
~/.rvm/gems/ruby-1.9.3-p194/gems/cucumber-1.2.1/lib/cucumber/feature_file.rb:44:in `insert'
这里有段代码e.message.insert(0, "#{@path}: ")可能会导致Encoding::CompatibilityError错误
ruby1.9, @path包含中文
需要在feature文件的头部加# language: zh-CN

*** Testing API with cucumber
资料:
http://www.anthonyeden.com/2010/11/testing-rest-apis-with-cucumber-and-rack-test/#comment-159
http://stackoverflow.com/questions/1722153/http-post-xml-content-from-cucumber

*** 文档资源
    http://cukes.info/step-definitions.html
** generator
bin/rails g model pa/bet --migration=false --fixture-replacement=fabrication
bin/rails g model pa/prebet --migration=false --fixture-replacement=fabrication
bin/rails g controller pa/term_notices --no-assets
bin/rails g controller SlsChannels --no-assets
bin/rails g model LotFarm --no-fixture --no-migration
bin/rails g model sls/activity_verify_charge --no-fixture --no-migration
bin/rails g business sls/business_commit_charge --no-fixture --no-migration
bin/rails g activity sls/activity_verify_charge --no-fixture --no-migration
zeus generate model pa/bb_job --fixture-replacement=fabrication 
** Building APIs With Rails
参考:
http://code.alexreisner.com/articles/building-apis-with-rails.html

** 资源
https://speakerdeck.com/u/j3/p/adventures-on-the-golden-path
** 参与rails的开发
*** 简化orm模型
1.业务逻辑和持久化分开
2.对开发api有更好的支持(默认没有js,css,html等)

** where
scope :fresh, lambda { where(['status not in (?)', '-3, 0, 1, 9'])}
** 自定义config
# config/initializers/load_config.rb
APP_CONFIG = YAML.load_file("#{Rails.root}/config/config.yml")[Rails.env]

# application.rb
if APP_CONFIG['perform_authentication']
  # Do stuff
end

参考:
http://stackoverflow.com/questions/1450285/how-to-define-custom-configuration-variables-in-rails

** rails初始化
参考: http://guides.rubyonrails.org/initialization.html

** delayed job
*** delayed_job
Set Delayed::Worker.delay_jobs = false to execute all jobs realtime.
项目地址:https://github.com/collectiveidea/delayed_job
# Start a single worker
RAILS_ENV=staging script/delayed_job start
# Start multiple workers, each in a separate process
RAILS_ENV=production script/delayed_job -n 4 start
# Stop all workers
RAILS_ENV=staging script/delayed_job stop

** zeus
zeus init
zeus start
zeus commands

zeus console
zeus server
zeus testrb test/unit/widget_test.rb
zeus rspec spec/widget_spec.rb
zeus generate model omg
zeus rake -T
zeus runner omg.rb

** Tabel.column
change_table :table do |t|
  t.column
  t.index
  t.timestamps
  t.change
  t.change_default
  t.rename
  t.references
  t.belongs_to
  t.string
  t.text
  t.integer
  t.float
  t.decimal
  t.datetime
  t.timestamp
  t.time
  t.date
  t.binary
  t.boolean
  t.remove
  t.remove_references
  t.remove_belongs_to
  t.remove_index
  t.remove_timestamps
end

** ActiveModel::Dirty
参考:http://stackoverflow.com/questions/5501334/how-to-properly-handle-changed-attributes-in-a-rails-before-save-hook

person = Person.find_by_name('Uncle Bob')
person.changed?       # => false
person.name = 'Bob'
person.changed?       # => true
person.name_changed?  # => true
person.name_was       # => 'Uncle Bob'
person.name_change    # => ['Uncle Bob', 'Bob']

** whenever
whenever --set environment=development -i
whenever --set environment=staging -i

** rest-client
*** set timeout
req = RestClient::Resource.new(CONFIG['batch_url'], :timeout => TT, :open_timeout => OP_TT)
req.post

** Untangle Domain and Persistence Logic with Curator
参考:https://www.braintreepayments.com/braintrust/untangle-domain-and-persistence-logic-with-curator

** DSL
http://martinfowler.com

** 业务逻辑层和持久程层分离
https://gist.github.com/2838490

** Bundle
bundle install --without test
If you want a dependency to be loaded only in a certain Rails environment,
place it in a group named after that Rails environment
*** group

** rvm gemset
rvm gemset create ruby1.9.3@rails328
rvm use ruby1.9.3@rails328

** 部署脚本
*** nginx + passenger
#!/bin/tcsh

set app_dir = "/srv/rorapps/lot_zhuihao";
set socket = "${app_dir}/tmp/sockets/rails.socket";
set pid_file = "${app_dir}/tmp/pids/passenger.pid";
set user = "www";
set passenger_exe = "passenger";
set opts=" --max-pool-size 10 --user ${user} -S ${socket} -e ${RAILS_ENV} --pid-file ${pid_file} -d";

cd $app_dir

switch($1)
case "init"
  rm -f $pid_file
  $0 start
breaksw

case "stop":
  $passenger_exe $1  --pid-file $pid_file
breaksw

case "start":
  $passenger_exe $1 $opts
breaksw


case "restart":
  $0 stop && $0 start
breaksw


case "reload":
  touch $app_dir/tmp/restart.txt
breaksw

case "status":
  $passenger_exe $1 --pid-file $pid_file
breaksw

default:
  echo "$0 [init|stop|start|status|reload]"
endsw
** 时区
rake time:zones:all
config.time_zone = 'Beijing'
config.active_record.default_timezone = :local
Rails stores at +0000 Time zone by default

** HTML标签辅助方法
*** select
select '', 'lot_name', ['重庆时时彩', '双色球'], include_blank: false
select '', 'terminal_no', [['任意', nil]\]

options_for_contest_itype = [['photo', 0], ['video', 1], ['word', 2], ['audio', 4]]
select 'contest', 'itype', options_for_contest_itype, selected: @contest.itype

select '', 'contest[sponsoring[][sponsor]]', options_for_contest_sponsors, selected: sponsoring.sponsor.id

*** radio button
radio_button '', 'u_depoted', true, checked: @pre_term.depoted
** API设计
*** Versioned Controller
Applications.routes.draw do
  namespace :v1 do
    resources :orders # V1::OrdersController, /v1/orders
  end
  namespace :v2 do
    resources :orders # V2::OrdersController, /v2/orders
  end
end

Application.router.draw do
  constraints(:version => 1) do # namespace V1
    resources :orders # V1::OrdersController, /orders
  end
  constraints(:version => 2)  do # namespace V2
    resources :orders # V2::OrdersController, /orders
  end
end

** 日志
清空日志: rake log:clear

** 移动web
http://aulara.cn/m/users/login/?next=/m/

** cycle helper
<tr class=<%= cycle('even', 'odd') %>>

** http basic auth
class Admin::ApplicationController < ApplicationController
  
  USER_NAME, PASSWORD = "zhou", "dashiyebushuo"
  
  before_filter :admin_authenticate


  private

  def admin_authenticate
    authenticate_or_request_with_http_basic do |user_name, password|
      user_name == USER_NAME && password == PASSWORD
    end
  end

end

** Asset Pipeline
http://guides.rubyonrails.org/asset_pipeline.html
** 图片验证码
http://www.fmwconcepts.com/imagemagick/captcha/index.php
** Clean Code
*** Refactor Fat Models
1. Extract Value Objects
2. Extract Service Objects
3. Extract Form Objects
4. Extract Query Objects
5. Introduce View Objects
6. Extract Pollicy Objects
7. Extract Decorators
*** 技术文章
- http://blog.codeclimate.com/blog/2012/10/17/7-ways-to-decompose-fat-activerecord-models/
- https://github.com/zlx/userful_article/blob/master/best_practices/7_patterns_to_refactor_fat_ActiveRecord_Models.md

** WebSockets on Rails 4 and Ruby 2
http://www.pogoapp.com/blog/posts/websockets-on-rails-4-and-ruby-2?utm_source=rubyweekly&utm_medium=email

** 教程
- http://about.ac/rails-tutorial-2nd-cn/

** Rails项目重构
- http://yedingding.com/2013/03/04/steps-to-refactor-controller-and-models-in-rails-projects.html

** Rails学习网站
- http://railsapps.github.com
- http://railsapps.github.com/rails-javascript-include-external.html

** 生成带namespace的controller
** rake任务在生产环境输出日志
Rails.logger.auto_flushing = true

** rake常用任务
- rake db:version 查看迁移版本
*** 恢复迁移(我需要修改某个历史的migration文件的迁移逻辑，比如20080930121212)
- rake db:migrate:down VERSION=20080930121212
- rake db:migrate
** remove turbolinks from rails4
- Remove the gem 'turbolinks' line from your Gemfile.
- Remove the //= require turbolinks from your app/assets/javascripts/application.js.
- Remove the two "data-turbolinks-track" => true hash key/value pairs from your app/views/layouts/application.html.erb.

** form_tag
- form_tag('/upload', multipart: true)
<%= form_tag('/posts') do -%>
  <div><%= submit_tag 'Save' %></div>
<% end -%>
** helper_method
#application_controller.rb
def current_user
  @current_user ||= User.find_by_id!(session[:user_id])
end
helper_method :current_user

** asset_path
.css.erb   
background-image:url(<%=asset_path "admin/logo.png"%>);
- 实例
首先将美工给的common.css文件改名为common.css.erb
然后利用asset_path来引入image
.header{width:960px;height:75px;background:url(<%= asset_path 'main_bg.png' %>) 0 0 repeat-x;overflow:hidden;}

** autoload_path
- config.autoload_paths += Dir[Rails.root.join('app', 'lib')]
** rename_column						  
rename_column :table_name, :old_column, :new_column
** Bug
*** rails4.0好像无法加载有定义Protocol常量的文件
比如文件upload.rb处于autoload_paths的下面，
module Protocol
  module Upload
    def upload_image
    end
  end
end
但是无法加载upload.rb文件，当我把它改成
module Upload
  module Image
    def upload_image
    end
  end
end
就能加载了
** rails的开源项目
- http://www.opensourcerails.com/
** rails mime types
"*/*"                      => :all
"text/plain"               => :text
"text/html"                => :html 
"application/xhtml+xml"    => :html
"text/javascript"          => :js 
"application/javascript"   => :js 
"application/x-javascript" => :js 
"text/calendar"            => :ics   
"text/csv"                 => :csv   
"application/xml"          => :xml 
"text/xml"                 => :xml 
"application/x-xml"        => :xml 
"text/yaml"                => :yaml 
"application/x-yaml"       => :yaml 
"application/rss+xml"      => :rss   
"application/atom+xml"     => :atom  
"application/json"         => :json 
"text/x-json"              => :json
** belongs_to
*** 实例01
class HeatEntity < ActiveRecord::Base
  belongs_to :heat, class_name: 'ContestHeat'
  belongs_to :entity
end

** has_many
*** 实例01
class ContestHeat < ActiveRecord::Base
  has_many :entities, through: :heat_entities
end
*** 实例02
class ContestRound < ActiveRecord::Base
  has_many :groups, class_name: 'ContestGroup'
  has_many :heats, class_name: 'ContestHeat'
end

class ContestGroup < ActiveRecord::Base
  has_many :heats, class_name: 'ContestHeat'
end
   
** many-to-many
*** 实例
class HeatEntity < ActiveRecord::Base
  belongs_to :heat, class_name: 'ContestHeat'
  belongs_to :entity
end

class ContestHeat < ActiveRecord::Base
  has_many :heat_entities, foreign_key: 'heat_id'
  has_many :entities, through: :heat_entities
  belongs_to :round, class_name: 'ContestRound'
end
** deploy
*** http://blog.codeclimate.com/blog/2013/10/02/high-speed-rails-deploys-with-git
deploy:update_code — Resets the Git working directory to the latest code we want to deploy.
bundle:install:if_changed — Checks if either the Gemfile or Gemfile.lock were changed, and if so invokes the bundle:install task. Most deploys don’t include Gemfile changes so this saves some time.
assets:precompile:if_changed — Similar to the above, this invokes the assets:precompile task if and only if there were changes that may necessitate asset updates. We look for changes to three paths: app/assets, Gemfile.lock, and config. Asset pre-compilation is notoriously slow, and this saves us a lot of time when pushing out changes that only touch Ruby code or configuration.
deploy:tag — Creates a Git tag on the app server for the release. We never push these tags upstream to GitHub.
deploy:restart — This part varies depending on your application server of choice. For us, we use God to send a USR2 signal to our Unicorn master process.
deploy:verify — This is the most complex part. The simplest approach would have Capistrano wait until the Unicorn processes reboot (with a timeout). However, since Unicorn reboots take 30 seconds, I didn’t want to wait all that extra time just to confirm something that works 99% of the time. Using every ounce of Unix-fu I could muster, I cobbled together a solution using the at utility:
echo 'curl -sS http://127.0.0.1:3000/system/revision | grep "c7fe01a813" > /dev/null || echo "Expected SHA: c7fe01a813" | mail -s "Unicorn restart failed" ops@example.com' | at now + 2 minutes

** jsonp
*** 实例
- render json: ContestsIndexJson << {cated_contests: cated_contests}, callback: params[:callback]
** validates
- 参考: http://api.rubyonrails.org/classes/ActiveModel/Validations/ClassMethods.html
*** normal use
validates :terms, acceptance: true
validates :password, confirmation: true
validates :username, exclusion: { in: %w(admin superuser) }
validates :email, format: { with: /\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\Z/i, on: :create }
validates :age, inclusion: { in: 0..9 }
validates :first_name, length: { maximum: 30 }
validates :age, numericality: true
validates :username, presence: true
validates :username, uniqueness: true

validates :email, format: /@/
validates :gender, inclusion: %w(male female)
validates :password, length: 6..20

*** custome validator
class EmailValidator < ActiveModel::EachValidator
  def validate_each(record, attribute, value)
    record.errors.add attribute, (options[:message] || "is not an email") unless
      value =~ /\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\z/
  end
end

class Person
  include ActiveModel::Validations
  attr_accessor :name, :email

  validates :name, presence: true, uniqueness: true, length: { maximum: 100 }
  validates :email, presence: true, email: true
end

*** 带条件的验证
validates :password, presence: true, confirmation: true, if: :password_required?
validates :token, uniqueness: true, strict: TokenGenerationException
validates :password, presence: { if: :password_required?, message: 'is forgotten.' }, confirmation: true

*** 实例
validates :name, presence: true, uniqueness: true
validates :email, format: /@/, if: ->(sponsor) { sponsor.email.present? }

validates :email, presence: {if: ->(user){ user.email.nil?} }, uniqueness: true
validates :mobile, presence: {if: ->(user){ user.mobile.nil?} }, uniqueness: true  

  validates :email,
  presence: {if: ->(user){ user.mobile.nil?} },
  uniqueness: {if: ->(user){user.email.present?}},
  if: ->(user){ not user.created_ref == UserCreatedRef['后台赞助商'].code}
      
  validates :mobile,
  presence: {if: ->(user){ user.email.nil?} },
  uniqueness: {if: ->(user){user.mobile.present?}},
  if: ->(user){ not user.created_ref == UserCreatedRef['后台赞助商'].code}

** associations
- 参考: http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html
*** 自动生成的方法
Singular associations (one-to-one)

                                  |            |  belongs_to  |
generated methods                 | belongs_to | :polymorphic | has_one
----------------------------------+------------+--------------+---------
other                             |     X      |      X       |    X
other=(other)                     |     X      |      X       |    X
build_other(attributes={})        |     X      |              |    X
create_other(attributes={})       |     X      |              |    X
create_other!(attributes={})      |     X      |              |    X

Collection associations (one-to-many / many-to-many)
                                  |       |          | has_many
generated methods                 | habtm | has_many | :through
----------------------------------+-------+----------+----------
others                            |   X   |    X     |    X
others=(other,other,...)          |   X   |    X     |    X
other_ids                         |   X   |    X     |    X
other_ids=(id,id,...)             |   X   |    X     |    X
others<<                          |   X   |    X     |    X
others.push                       |   X   |    X     |    X
others.concat                     |   X   |    X     |    X
others.build(attributes={})       |   X   |    X     |    X
others.create(attributes={})      |   X   |    X     |    X
others.create!(attributes={})     |   X   |    X     |    X
others.size                       |   X   |    X     |    X
others.length                     |   X   |    X     |    X
others.count                      |   X   |    X     |    X
others.sum(*args)                 |   X   |    X     |    X
others.empty?                     |   X   |    X     |    X
others.clear                      |   X   |    X     |    X
others.delete(other,other,...)    |   X   |    X     |    X
others.delete_all                 |   X   |    X     |    X
others.destroy(other,other,...)   |   X   |    X     |    X
others.destroy_all                |   X   |    X     |    X
others.find(*args)                |   X   |    X     |    X
others.exists?                    |   X   |    X     |    X
others.distinct                   |   X   |    X     |    X
others.uniq                       |   X   |    X     |    X
others.reset                      |   X   |    X     |    X
*** 实际例子
sponsor.create_user(name: name,
		email: email,
		created_ref: UserCreatedRef['后台赞助商'].code
		)
sponsor.save

** validate errors
- ActiveRecord对象的错误模型类似下面:

user.errors #=>
#<ActiveModel::Errors:0x007f8fe8288370
 @base=
  #<User id: nil, name: nil, birthday: nil, gender: nil, mobile: nil, email: nil, avatar: nil, password_hash: nil, password_salt: nil, sn: nil, status: nil, level: 1, point_count: 0, vote_count: 0, created_at: nil, updated_at: nil, marry: 0, location: nil, role: "user", created_ref: 0>,
 @messages=
  {:email=>["can't be blank", "has already been taken"],
   :mobile=>["can't be blank", "has already been taken"]}>


user.errors.messages #=>
{:email=>["can't be blank", "has already been taken"],
 :mobile=>["can't be blank", "has already been taken"]}

user.errors.sort  #=>
[[:email, "can't be blank"],
 [:email, "has already been taken"],
 [:mobile, "can't be blank"],
 [:mobile, "has already been taken"]]

user.errors.to_a #=>
["Email can't be blank",
 "Email has already been taken",
 "Mobile can't be blank",
 "Mobile has already been taken"]
 
user.errors.keys #=>
[:email, :mobile]

** 用户，关注，粉丝的三者关系的在activerecord中的快速实现
*** 表结构
follows
Column       | Type     | Modifiers | Comment 
------------ | -------- | --------- | --------
following_id | integer  |           |  被关注者的id
follower_id  | integer  |           |  关注者的id 
created_at   | datetime |           |         
updated_at   | datetime |           |         

users
Column        | Type     | Modifiers    | Comment                                                                                                
------------- | -------- | ------------ |------------------
id            | integer  |              |
sn            | string   |              |                                                                                                        
gender        | integer  |              |  性别, 0 女, 1 男 

*** 模型
class Follow < ActiveRecord::Base
  belongs_to :following, class_name: 'User'
  belongs_to :follower, class_name: 'User'
end

class User < ActivieRecord::Base

  # 有许多偶像
  has_many :following_relationships, class_name: 'Follow', foreign_key: 'follower_id'
  has_many :followings, through: :following_relationships

  # 有许多粉丝
  has_many :follower_relationships, class_name: 'Follow', foreign_key: 'following_id'
  has_many :followers, through: :follower_relationships

end

** save without validate
user.save(validate: false)
** migration: rename table name
class RenameTalbeEntityInviteLogsToHeatInviteLogs < ActiveRecord::Migration
  def change
    rename_table :entity_invite_logs, :heat_invite_logs
  end
end

** migration transformations
*** change_column(table_name, column_name, type, options)
- change_column :contests, :created_kind, :integer, default: 1  # 默认为赞助商创建
** assert
*** assert( test, [msg] ), Ensures that test is true
*** assert_not( test, [msg] ), Ensures that test is false.
*** assert_equal( expected, actual, [msg] ), Ensures that expected == actual is true.
*** assert_raises( exception1, exception2, ... ) { block }, Ensures that the given block raises one of the given exceptions.
- 实例
    assert_raise NoEnoughVoteOrCreditError do
      credit_log = FchkCredits::Vote << {user: user, entity: entity}
      end
** user agent
- 参考: http://stackoverflow.com/questions/7650799/is-there-a-way-to-detect-user-agent-in-rails-3-1
request.env["HTTP_USER_AGENT"]
#or
request.user_agent

** current absolute url
- 参考: http://stackoverflow.com/questions/2165665/how-do-i-get-the-current-url-in-ruby-on-rails
For Rails 3.2 or Rails 4 you should use request.original_url to get the current URL. More detail.

For Rails 3: You want "#{request.protocol}#{request.host_with_port}#{request.fullpath}", since request.url is now deprecated.

For Rails 2: You want request.url instead of request.request_uri. This combines the protocol (usually http://) with the host, and request_uri to give you the full address.

** Test Unit
- 参考: http://guides.rubyonrails.org/testing.html
*** 执行测试
- rake test test/models/post_test.rb
- rake test test/models/post_test.rb test_the_truth
- ruby -Itest test/models/credit_allocation/non_survey_contest_test.rb
*** Setup and Teardown
require 'test_helper'
 
class PostsControllerTest < ActionController::TestCase
 
  # called before every single test
  setup :initialize_post
 
  # called after every single test
  def teardown
    @post = nil
  end
 
  test "should show post" do
    get :show, id: @post.id
    assert_response :success
  end
 
  test "should update post" do
    patch :update, id: @post.id, post: {}
    assert_redirected_to post_path(assigns(:post))
  end
 
  test "should destroy post" do
    assert_difference('Post.count', -1) do
      delete :destroy, id: @post.id
    end
 
    assert_redirected_to posts_path
  end
 
  private
 
  def initialize_post
    @post = posts(:one)
  end
 
end

*** 断言
*** Integration Testing 集成测试
- http://guides.rubyonrails.org/testing.html#integration-testing     
- generate integration test: rails generate integration_test user_flows
**** 例子
require 'test_helper'
 
class UserFlowsTest < ActionDispatch::IntegrationTest
  fixtures :users
 
  test "login and browse site" do
 
    # User david logs in
    david = login(:david)
    # User guest logs in
    guest = login(:guest)
 
    # Both are now available in different sessions
    assert_equal 'Welcome david!', david.flash[:notice]
    assert_equal 'Welcome guest!', guest.flash[:notice]
 
    # User david can browse site
    david.browses_site
    # User guest can browse site as well
    guest.browses_site
 
    # Continue with other assertions
  end
 
  private
 
  module CustomDsl
    def browses_site
      get "/products/all"
      assert_response :success
      assert assigns(:products)
    end
  end
 
  def login(user)
    open_session do |sess|
      sess.extend(CustomDsl)
      u = users(user)
      sess.https!
      sess.post "/login", username: u.username, password: u.password
      assert_equal '/welcome', path
      sess.https!(false)
    end
  end
end
** Function Test Example 01
require 'test_helper'

class PlayHeatControllerTest < ActionController::TestCase

  def setup
    @user = CreateUser << {name: 'jim', email: 'jim@mail.com'}
    @contest = CreateContest << {title: 'Title', user: @user, mode: 0}
    @entities = []
    8.times do
      entity = CreateEntity << {user: @user, contest: @contest}
      @entities << entity
    end
    GroupingContestEntities << {contest: @contest}
    @round = @contest.rounds.where(level: 1).first
    @heat = CreateHeat << {round: @round}
  end

  test '要扣积分等于0，无确认' do
    vote_num, credit_num = init_user 50, 100
    
    get :index, {user_sn: @user.sn, heat_sn: @heat.sn, choices: choices}
    res = JSON.parse @response.body
    @user.reload
    assert_equal res["status"]["resp_code"], 0
    assert_equal @user.vote_count, vote_num - 1
    assert_equal @user.point_count, credit_num
  end

  test '要扣积分大于0, 无确认' do
    init_user 50, 100
    duplicate_vote_entity
    vote_num, credit_num = init_user 50, 100

    get :index, {user_sn: @user.sn, heat_sn: @heat.sn, choices: choices}

    res = JSON.parse @response.body
    @user.reload
    puts res.inspect
    assert_equal res["status"]["resp_code"], -47
    assert_equal @user.vote_count, vote_num
    assert_equal @user.point_count, credit_num
  end

  test '要扣积分等于0, 有确认' do
    vote_num, credit_num = init_user 50, 100
    
    get :index, {user_sn: @user.sn, heat_sn: @heat.sn, choices: choices, confirmed: 't'}
    res = JSON.parse @response.body
    @user.reload
    assert_equal res["status"]["resp_code"], 0
    assert_equal @user.vote_count, vote_num - 1
    assert_equal @user.point_count, credit_num
  end

  test '要扣积分大于0, 有确认' do
    init_user 50, 100
    duplicate_vote_entity
    vote_num, credit_num = init_user 50, 100

    get :index, {user_sn: @user.sn, heat_sn: @heat.sn, choices: choices, confirmed: 't'}

    res = JSON.parse @response.body
    @user.reload
    puts res.inspect
    assert_equal res["status"]["resp_code"], 0
    assert_equal @user.vote_count, vote_num - 1
    assert_equal @user.point_count, credit_num - 1
  end

  private
  
  def choices
    choice_index_maps = [[0, 1], [3, 2], [7, 5], [6, 4], [1, 3], [5, 6], [6, 3]]
    choice_index_maps.map {|mapper|
      l, r = mapper
      [@entities.fetch(l).sn, @entities.fetch(r).sn]
    }
  end

  def duplicate_vote_entity num = 1
    entity = Entity.where(sn: choices.last.last).first
    num.times do
      CreateVote << {entity: entity, user: @user}
      consume_credit = CalCreditForVote << {user: @user, entity: entity}
      FchkCreditsVote << {user: @user, entity: entity, consume_credit: consume_credit}
    end
  end

  def init_user(vote_num, credit_num)
    set_user_vote_count vote_num
    set_user_credit_count credit_num
    return vote_num, credit_num
  end

  def set_user_vote_count(num)
    @user.vote_count = num
    @user.save
  end

  def set_user_credit_count(num)
    @user.point_count = num
    @user.save
  end

end

** 开发环境下让应用跑在80端口下
sudo ssh devuser@localhost -L 80:localhost:3000 -N
- 参考: http://ruby-china.org/topics/16094

** Test Controllers
*** assert_redirected_to
class Partner::PreviewContestsControllerTest < ActionController::TestCase

  def setup
    @title = "比赛预览01"
    @description = "比赛预览01 500个字以内"
  end

  test "比赛预览" do
    post :create, {contest: {title: @title, description: @description}}
    preview_contest = PreviewContest.order('created_at DESC').first

    assert_redirected_to partner_preview_contest_landing_path(preview_contest)
  end
  
end

*** assert_response, assigns
class Partner::PreviewContestLandingControllerTest < ActionController::TestCase

  def setup
    @title = "比赛推广预览测试01"
    @description = "description"
    @preview_contest = CreatePreviewContest << {title: @title, description: @description}
  end

  test "比赛推广预览" do
    get :show, {id: @preview_contest.id}
    
    assert_response :success
    assert_not_nil assigns(:preview_contest)
  end
  
end

** assets
- https://rails-assets.org
*** Getting started
Gemfile
source 'https://rubygems.org'
+source 'https://rails-assets.org'

 gem 'rails'

 group :assets do
   gem 'sass-rails'
   gem 'uglifier'
   gem 'coffee-rails'
+  gem 'rails-assets-bootstrap'
+  gem 'rails-assets-angular'
+  gem 'rails-assets-leaflet'
 end

application.js

 //= require_self
+//= require bootstrap
+//= require angular
+//= require leaflet
 //= require_tree .
 //= require_tree shared
application.css

 /*
  *= require_self
+ *= require bootstrap
+ *= require leaflet
  *= require_tree .
  *= require_tree shared
  */

** asset pipeline
- http://guides.rubyonrails.org/asset_pipeline.html
*** disable asset pipeline
- config.assets.enabled = false
或者
- rails new appname --skip-sprockets
  
*** cache
- Fingerprinting is a technique that makes the name of a file dependent on the contents of the file
global-908e25f4bf641868d8683022a5b62f54.css
- Fingerprinting is enabled by default for production and disabled for all other environments
config.assets.digest

*** app/assets
此文件下的所有文件由Sprockets处理，并且在production环境下这些文件从来不会直接发给客户端
如果文件需要预处理，那么应该把文件放到app/assets下
public下的文件都将作为静态文件对待
*** disable controller asset
## config/application.rb
config.generators do |g|
  g.assets false
end

*** asset organization
- app/assets owned by the application
- lib/assets developer own libraries' code 不会被预编译
- vendor/assets owned by outside entities, such as code for JavaScript plugins and CSS frameworks 不会被预编译

*** search paths

app/assets/javascripts/home.js
lib/assets/javascripts/moovinator.js
vendor/assets/javascripts/slider.js
vendor/assets/somepackage/phonebox.js

would be referenced in a manifest like this:

//= require home
//= require moovinator
//= require slider
//= require phonebox

Assets inside subdirectories can also be accessed.

//= require sub/something

- view the search path: Rails.application.config.assets.paths 

- add additional asset paths:
  # config/application.rb
  config.assets.paths << Rails.root.join("lib", "videoplayer", "flash")

*** index files

lib/assets/library_name, the file lib/assets/library_name/index.js

//= require library_name

*** link to assets
<%= stylesheet_link_tag "application" %>
<%= javascript_include_tag "application" %>
<%= image_tag "rails.png" %>
<%= image_tag "icons/rails.png" %>

*** css and erb
.class { background-image: url(<%= asset_path 'image.png' %>) }
#logo { background: url(<%= asset_data_uri 'logo.png' %>) }

*** css and Sass
image-url("rails.png") becomes url(/assets/rails.png)
image-path("rails.png") becomes "/assets/rails.png".

*** JavaScript/CoffeeScript and ERB
$('#logo').attr({
  src: "<%= asset_path('logo.png') %>"
});

$('#logo').attr src: "<%= asset_path('logo.png') %>"

*** manifest files and directives
- compresses: Rails.application.config.assets.compress = true
- You can have as many manifest files as you need. For example the admin.css and admin.js manifest could contain the JS and CSS files that are used for the admin section of an application.

**** js manifest
// ...
//= require jquery
//= require jquery_ujs
//= require_tree .

- The require_tree directive tells Sprockets to recursively include all JavaScript files in the specified directory into the output

require_tree 加载文件时没有特定的顺序，所以要限定顺序加载文件时，可以使用require

**** css manifest
/* ...
*= require_self
*= require_tree .
*/

/* ...
*= require reset
*= require layout
*= require chrome
*/

*** preprocessing
- app/assets/stylesheets/projects.css.scss.erb is first processed as ERB, then SCSS, and finally served as CSS
- app/assets/javascripts/projects.js.coffee.erb is processed as ERB, then CoffeeScript, and served as JavaScript

*** in development

//= require core
//= require projects
//= require tickets

将生成下面的html

<script src="/assets/core.js?body=1"></script>
<script src="/assets/projects.js?body=1"></script>
<script src="/assets/tickets.js?body=1"></script>

若关闭调试: config.assets.debug = false，则生成，

<script src="/assets/application.js"></script>

*** in production

<%= javascript_include_tag "application" %>
<%= stylesheet_link_tag "application" %>

将生成与下面类似的html

<script src="/assets/application-908e25f4bf641868d8683022a5b62f54.js"></script>
<link href="/assets/application-4dd5b109ee3439da54f5bdfd78a80473.css" media="screen" rel="stylesheet" />

*** precompiling assets
Compiled assets are written to the location specified in config.assets.prefix. By default, this is the public/assets directory

$ RAILS_ENV=production bundle exec rake assets:precompile

If you have other manifests or individual stylesheets and JavaScript files to include, you can add them to the precompile array in config/application.rb:

- config.assets.precompile += ['admin.js', 'admin.css', 'swfObject.js']

*** local precompilation

There are several reasons why you might want to precompile your assets locally. Among them are:

You may not have write access to your production file system.
You may be deploying to more than one server, and want to avoid the duplication of work.
You may be doing frequent deploys that do not include asset changes.

In config/environments/development.rb, place the following line:

config.assets.prefix = "/dev-assets"
You will also need this in application.rb:

config.assets.initialize_on_precompile = false

*** css compression
- config.assets.css_compressor = :yui

*** javascript compression
- config.assets.js_compressor = :uglifier

Note that config.assets.compress must be set to true to enable JavaScript compression

*** changing the assets path

The public path that Sprockets uses by default is /assets.

This can be changed to something else:

config.assets.prefix = "/some_other_path"

** ActiveRecord::Base.attribte_names
Pa::Prebet.attribute_names

** html escape
ps = "terms: 要追期数<br/>" +
     "termeds: 已追期数<br/>" +
     "status: 0 可追, 1 终止追号"

<p><%=raw ps %></p>
<p><%= ps.html_safe %></p>
** spring preloader
- https://github.com/jonleighton/spring
*** 常用命令
- spring rake test test/functional/posts_controller_test.rb
- spring status
- bundle exec spring binstub --all
- spring rails g controller partner/contests
** Avoiding duplicate results when you do a join
   users = User.find(:all, 
  :conditions => ['users.id = lists.user_id'], 
  :joins => [:lists], 
  :order => 'users.username')
You can cause each found user to appear only once by using the :select option with “DISTINCT”:

users = User.find(:all, 
  :conditions => ['users.id = lists.user_id'], 
  :joins => [:lists], 
  :select => 'DISTINCT users.*'
  :order => 'users.username')
** 反模式
*** http://devblog.reverb.com/post/70344683203/5-architecture-anti-patterns-and-solutions-for-large
1. Service objects with many responsibilities
2. Un-namespaced classes in the domain layer
3. Including modules to share functionality
4. Any kind of dynamic method invocation
5. Do Not User Rails Helpers
** turn off automatic stylesheet/javascript generation
config.generators.stylesheets = false
config.generators.javascripts = false

** content_for, layout
- 参考: http://guides.rubyonrails.org/layouts_and_rendering.html
<html>
  <head>
  <%= yield :head %>
  </head>
  <body>
  <%= yield %>
  </body>
</html>

<% content_for :head do %>
  <title>A simple page</title>
<% end %>
 
<p>Hello, Rails!</p>

*** 实例

<!DOCTYPE html>
<html>
  <head>
    <%= yield :head_title %>
    <%= yield :head_meta %>
    <%= stylesheet_link_tag    "application", media: "all"%>
    <%= javascript_include_tag "application"%>
    <%= csrf_meta_tags %>
    <meta charset='utf-8' />
  </head>
  
  <body>
    
    <%= yield %>
    
  </body>
</html>

<% content_for :head_title do %>
  <title>创建赞助商比赛</title>
<% end %>


** xxx_field_tag
<%= text_field_tag 'contest[title]', @preview_contest.title %>
<%= text_area_tag 'contest[description]', @preview_contest.description %>
<%= hidden_field_tag "preview_contest_id", @preview_contest.id %>

** saving arrays, hashes, and other non-mappable objects in text columns
- 参考: http://api.rubyonrails.org/classes/ActiveRecord/Base.html
class AddCategoriesToPreviewContests < ActiveRecord::Migration
  def change
    add_column :preview_contests, :categories, :text  # 用于保存序列化后的比赛类别数组
  end
end

class PreviewContest < ActiveRecord::Base
  serialize :categories

end

preview_contest = PreviewContest.create(categories: ['汽车', '娱乐'], title: '比赛')
preview_contest.categories #=> ['汽车', '娱乐']


** 本地化
*** rails-i18n
** assets, sprockets实例
- 加入一个第三方插件My97DatePicker

插件的目录结构:
├── WdatePicker.js
├── calendar.js
├── index.css
├── lang
│   ├── en.js
│   ├── zh-cn.js
│   └── zh-tw.js
├── skin
│   ├── Calendar_Icon_Button_u180_normal.png
│   ├── Thumbs.db
│   ├── WdatePicker.css
│   ├── datePicker.gif
│   ├── default
│   │   ├── datepicker.css
│   │   └── img.gif
│   └── whyGreen
│       ├── bg.jpg
│       ├── datepicker.css
│       └── img.gif
└── ?\200?\217\221?\214\205
    ├── lang
    │   ├── en.js
    │   ├── zh-cn.js
    │   └── zh-tw.js
    ├── readme.txt
    └── skin
        ├── WdatePicker.css
        ├── datePicker.gif
        ├── default
        │   ├── datepicker.css
        │   └── img.gif
        └── whyGreen
            ├── bg.jpg
            ├── datepicker.css
            └── img.gif

1. 在vender/assets目录下创建一个文件夹date ps: 其实可以起任意一个合法的名字
2. 将My97DatePicker这个插件拷贝到 date 目录下
3. 在app/assets/javascripts/application.js加入 //=require My97DatePicker,
此时application.js文件类似于:   
//= require jquery
//= require jquery_ujs
//= require My97DatePicker
//= require_tree .
4. 在app/assets/stylesheets/application.css加入 *=require My97DatePicker,
此时application.css文件类似于:
/*
 *= require_self
 *= require_tree .
 *= require My97DatePicker
 */

5. 在vender/assets/date/My97DatePicker 目录下加入 index.js, index.css两个文件, 内容分别为:
//
//
//
//= require_tree .

和

/*
 *
 *
 *
 *= require_tree ./skin
 */
   
*** 加入swfupload   
** 复杂的form表单参数
- 参考: http://codecampo.com/topics/388
- 参考: http://blog.twoalex.com/2010/11/21/can-an-html-form-generate-an-ordered-array-of-hashes-with-rails/
"prizes"=>[{"description"=>"abc", "sponsor_logo_url"=>"", "image_url"=>"", "detail_url"=>""}, {"description"=>"efg", "sponsor_logo_url"=>"", "image_url"=>"", "detail_url"=>""}]}

<div class='description'>
  <%= text_area_tag "contest[prizes][][description]" %>
</div>
<div class='description'>
  <%= text_area_tag "contest[prizes][][description]" %>
</div>
