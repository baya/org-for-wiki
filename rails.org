* Rails
** 构造联合查询
def self.search(title, category_id, city_id)
    rel = scoped
    rel = rel.where('title    like ?', "%#{title}%") if(title)
    rel = rel.where('category_id = ?', category_id)  if(category_id)
    rel = rel.where('city_id     = ?', city_id)      if(city_id)
    rel
end

** 调用save方法时的callback顺序
before_validation
before_validation :on => :create
after_validation
after_validation  :on => :create
before_save
before_create
after_create
after_save
** callback方法之间的一些差别
- 参考: http://stackoverflow.com/questions/6422199/what-is-the-difference-between-after-create-and-after-save-and-when-to-use-w
- after_create only works once - just after the record is first created.
- after_save works every time you save the object - even if you're just updating it many years later
** cucumber
*** 搭建命令
rails generate cucumber:install --help
rails generate cucumber:install
bin/cucumber --i18n zh-CN
*** 关键词
| feature          | "功能"                      |
| background       | "背景"                      |
| scenario         | "场景", "剧本"               |
| scenario_outline | "场景大纲", "剧本大纲"        |
| examples         | "例子"                      |
| given            | "* ", "假如", "假设", "假定" |
| when             | "* ", "当"                  |
| then             | "* ", "那么"                |
| and              | "* ", "而且", "并且", "同时" |
| but              | "* ", "但是"                |
| given (code)     | "假如", "假设", "假定"       |
| when (code)      | "当"                        |
| then (code)      | "那么"                      |
| and (code)       | "而且", "并且", "同时"       |
| but (code)       | "但是"                      |

| feature          | "Feature", "Business Need", "Ability"   |
| background       | "Background"                            |
| scenario         | "Scenario"                              |
| scenario_outline | "Scenario Outline", "Scenario Template" |
| examples         | "Examples", "Scenarios"                 |
| given            | "* ", "Given "                          |
| when             | "* ", "When "                           |
| then             | "* ", "Then "                           |
| and              | "* ", "And "                            |
| but              | "* ", "But "                            |
| given (code)     | "Given"                                 |
| when (code)      | "When"                                  |
| then (code)      | "Then"                                  |
| and (code)       | "And"                                   |
| but (code)       | "But"                                   |

*** 场景大纲
Scenario Outline: eating
  Given there are <start> cucumbers
  When I eat <eat> cucumbers
  Then I should have <left> cucumbers

  Examples:
    | start | eat | left |
    |  12   |  5  |  7   |
    |  20   |  5  |  15  |

参考:
https://github.com/cucumber/cucumber/wiki/Scenario-Outlines

*** Tags
cucumber --tags @debug
参考:
ohttps://github.com/cucumber/cucumber/wiki/Tags   

*** 错误记录
使用"功能"这个关键词会导致Gherkin::Lexer::LexingError错误
~/.rvm/gems/ruby-1.9.3-p194/gems/cucumber-1.2.1/lib/cucumber/feature_file.rb:44:in `insert'
这里有段代码e.message.insert(0, "#{@path}: ")可能会导致Encoding::CompatibilityError错误
ruby1.9, @path包含中文
需要在feature文件的头部加# language: zh-CN

*** Testing API with cucumber
资料:
http://www.anthonyeden.com/2010/11/testing-rest-apis-with-cucumber-and-rack-test/#comment-159
http://stackoverflow.com/questions/1722153/http-post-xml-content-from-cucumber

*** 文档资源
    http://cukes.info/step-definitions.html
** generator
bin/rails g model pa/bet --migration=false --fixture-replacement=fabrication
bin/rails g model pa/prebet --migration=false --fixture-replacement=fabrication
bin/rails g controller pa/term_notices --no-assets
bin/rails g controller SlsChannels --no-assets
bin/rails g model LotFarm --no-fixture --no-migration
bin/rails g model sls/activity_verify_charge --no-fixture --no-migration
bin/rails g business sls/business_commit_charge --no-fixture --no-migration
bin/rails g activity sls/activity_verify_charge --no-fixture --no-migration
zeus generate model pa/bb_job --fixture-replacement=fabrication 
** Building APIs With Rails
参考:
http://code.alexreisner.com/articles/building-apis-with-rails.html

** 资源
https://speakerdeck.com/u/j3/p/adventures-on-the-golden-path
** 参与rails的开发
*** 简化orm模型
1.业务逻辑和持久化分开
2.对开发api有更好的支持(默认没有js,css,html等)

** where
scope :fresh, lambda { where(['status not in (?)', '-3, 0, 1, 9'])}
** 自定义config
# config/initializers/load_config.rb
APP_CONFIG = YAML.load_file("#{Rails.root}/config/config.yml")[Rails.env]

# application.rb
if APP_CONFIG['perform_authentication']
  # Do stuff
end

参考:
http://stackoverflow.com/questions/1450285/how-to-define-custom-configuration-variables-in-rails

** rails初始化
参考: http://guides.rubyonrails.org/initialization.html

** delayed job
*** delayed_job
Set Delayed::Worker.delay_jobs = false to execute all jobs realtime.
项目地址:https://github.com/collectiveidea/delayed_job
# Start a single worker
RAILS_ENV=staging script/delayed_job start
# Start multiple workers, each in a separate process
RAILS_ENV=production script/delayed_job -n 4 start
# Stop all workers
RAILS_ENV=staging script/delayed_job stop

** zeus
zeus init
zeus start
zeus commands

zeus console
zeus server
zeus testrb test/unit/widget_test.rb
zeus rspec spec/widget_spec.rb
zeus generate model omg
zeus rake -T
zeus runner omg.rb

** Tabel.column
change_table :table do |t|
  t.column
  t.index
  t.timestamps
  t.change
  t.change_default
  t.rename
  t.references
  t.belongs_to
  t.string
  t.text
  t.integer
  t.float
  t.decimal
  t.datetime
  t.timestamp
  t.time
  t.date
  t.binary
  t.boolean
  t.remove
  t.remove_references
  t.remove_belongs_to
  t.remove_index
  t.remove_timestamps
end

** ActiveModel::Dirty
参考:http://stackoverflow.com/questions/5501334/how-to-properly-handle-changed-attributes-in-a-rails-before-save-hook

person = Person.find_by_name('Uncle Bob')
person.changed?       # => false
person.name = 'Bob'
person.changed?       # => true
person.name_changed?  # => true
person.name_was       # => 'Uncle Bob'
person.name_change    # => ['Uncle Bob', 'Bob']

** whenever
whenever --set environment=development -i
whenever --set environment=staging -i

** rest-client
*** set timeout
req = RestClient::Resource.new(CONFIG['batch_url'], :timeout => TT, :open_timeout => OP_TT)
req.post

** Untangle Domain and Persistence Logic with Curator
参考:https://www.braintreepayments.com/braintrust/untangle-domain-and-persistence-logic-with-curator

** DSL
http://martinfowler.com

** 业务逻辑层和持久程层分离
https://gist.github.com/2838490

** Bundle
bundle install --without test
If you want a dependency to be loaded only in a certain Rails environment,
place it in a group named after that Rails environment
*** group

** rvm gemset
rvm gemset create ruby1.9.3@rails328
rvm use ruby1.9.3@rails328

** 部署脚本
*** nginx + passenger
#!/bin/tcsh

set app_dir = "/srv/rorapps/lot_zhuihao";
set socket = "${app_dir}/tmp/sockets/rails.socket";
set pid_file = "${app_dir}/tmp/pids/passenger.pid";
set user = "www";
set passenger_exe = "passenger";
set opts=" --max-pool-size 10 --user ${user} -S ${socket} -e ${RAILS_ENV} --pid-file ${pid_file} -d";

cd $app_dir

switch($1)
case "init"
  rm -f $pid_file
  $0 start
breaksw

case "stop":
  $passenger_exe $1  --pid-file $pid_file
breaksw

case "start":
  $passenger_exe $1 $opts
breaksw


case "restart":
  $0 stop && $0 start
breaksw


case "reload":
  touch $app_dir/tmp/restart.txt
breaksw

case "status":
  $passenger_exe $1 --pid-file $pid_file
breaksw

default:
  echo "$0 [init|stop|start|status|reload]"
endsw
** 时区
rake time:zones:all
config.time_zone = 'Beijing'
config.active_record.default_timezone = :local
Rails stores at +0000 Time zone by default

** HTML标签辅助方法
*** select
select '', 'lot_name', ['重庆时时彩', '双色球'], include_blank: false
select '', 'terminal_no', [['任意', nil]\]

options_for_contest_itype = [['photo', 0], ['video', 1], ['word', 2], ['audio', 4]]
select 'contest', 'itype', options_for_contest_itype, selected: @contest.itype

select '', 'contest[sponsoring[][sponsor]]', options_for_contest_sponsors, selected: sponsoring.sponsor.id

*** radio button
radio_button '', 'u_depoted', true, checked: @pre_term.depoted
** API设计
*** Versioned Controller
Applications.routes.draw do
  namespace :v1 do
    resources :orders # V1::OrdersController, /v1/orders
  end
  namespace :v2 do
    resources :orders # V2::OrdersController, /v2/orders
  end
end

Application.router.draw do
  constraints(:version => 1) do # namespace V1
    resources :orders # V1::OrdersController, /orders
  end
  constraints(:version => 2)  do # namespace V2
    resources :orders # V2::OrdersController, /orders
  end
end

** 日志
清空日志: rake log:clear

** 移动web
http://aulara.cn/m/users/login/?next=/m/

** cycle helper
<tr class=<%= cycle('even', 'odd') %>>

** http basic auth
class Admin::ApplicationController < ApplicationController
  
  USER_NAME, PASSWORD = "zhou", "dashiyebushuo"
  
  before_filter :admin_authenticate


  private

  def admin_authenticate
    authenticate_or_request_with_http_basic do |user_name, password|
      user_name == USER_NAME && password == PASSWORD
    end
  end

end

** Asset Pipeline
http://guides.rubyonrails.org/asset_pipeline.html
** 图片验证码
http://www.fmwconcepts.com/imagemagick/captcha/index.php
** Clean Code
*** Refactor Fat Models
1. Extract Value Objects
2. Extract Service Objects
3. Extract Form Objects
4. Extract Query Objects
5. Introduce View Objects
6. Extract Pollicy Objects
7. Extract Decorators
*** 技术文章
- http://blog.codeclimate.com/blog/2012/10/17/7-ways-to-decompose-fat-activerecord-models/
- https://github.com/zlx/userful_article/blob/master/best_practices/7_patterns_to_refactor_fat_ActiveRecord_Models.md

** WebSockets on Rails 4 and Ruby 2
http://www.pogoapp.com/blog/posts/websockets-on-rails-4-and-ruby-2?utm_source=rubyweekly&utm_medium=email

** 教程
- http://about.ac/rails-tutorial-2nd-cn/

** Rails项目重构
- http://yedingding.com/2013/03/04/steps-to-refactor-controller-and-models-in-rails-projects.html

** Rails学习网站
- http://railsapps.github.com
- http://railsapps.github.com/rails-javascript-include-external.html

** 生成带namespace的controller
** rake任务在生产环境输出日志
Rails.logger.auto_flushing = true

** rake常用任务
- rake db:version 查看迁移版本
*** 恢复迁移(我需要修改某个历史的migration文件的迁移逻辑，比如20080930121212)
- rake db:migrate:down VERSION=20080930121212
- rake db:migrate
** remove turbolinks from rails4
- Remove the gem 'turbolinks' line from your Gemfile.
- Remove the //= require turbolinks from your app/assets/javascripts/application.js.
- Remove the two "data-turbolinks-track" => true hash key/value pairs from your app/views/layouts/application.html.erb.

** form_tag
- form_tag('/upload', multipart: true)

** helper_method
#application_controller.rb
def current_user
  @current_user ||= User.find_by_id!(session[:user_id])
end
helper_method :current_user

** asset_path
.css.erb   
background-image:url(<%=asset_path "admin/logo.png"%>);
- 实例
首先将美工给的common.css文件改名为common.css.erb
然后利用asset_path来引入image
.header{width:960px;height:75px;background:url(<%= asset_path 'main_bg.png' %>) 0 0 repeat-x;overflow:hidden;}

** autoload_path
- config.autoload_paths += Dir[Rails.root.join('app', 'lib')]
** rename_column						  :migration:
rename_column :table_name, :old_column, :new_column
** Bug
*** rails4.0好像无法加载有定义Protocol常量的文件
比如文件upload.rb处于autoload_paths的下面，
module Protocol
  module Upload
    def upload_image
    end
  end
end
但是无法加载upload.rb文件，当我把它改成
module Upload
  module Image
    def upload_image
    end
  end
end
就能加载了
** rails的开源项目
- http://www.opensourcerails.com/
** rails mime types
"*/*"                      => :all
"text/plain"               => :text
"text/html"                => :html 
"application/xhtml+xml"    => :html
"text/javascript"          => :js 
"application/javascript"   => :js 
"application/x-javascript" => :js 
"text/calendar"            => :ics   
"text/csv"                 => :csv   
"application/xml"          => :xml 
"text/xml"                 => :xml 
"application/x-xml"        => :xml 
"text/yaml"                => :yaml 
"application/x-yaml"       => :yaml 
"application/rss+xml"      => :rss   
"application/atom+xml"     => :atom  
"application/json"         => :json 
"text/x-json"              => :json
** belongs_to
*** 实例01
class HeatEntity < ActiveRecord::Base
  belongs_to :heat, class_name: 'ContestHeat'
  belongs_to :entity
end

** has_many
*** 实例01
class ContestHeat < ActiveRecord::Base
  has_many :entities, through: :heat_entities
end
*** 实例02
class ContestRound < ActiveRecord::Base
  has_many :groups, class_name: 'ContestGroup'
  has_many :heats, class_name: 'ContestHeat'
end

class ContestGroup < ActiveRecord::Base
  has_many :heats, class_name: 'ContestHeat'
end
   
** many-to-many
*** 实例
class HeatEntity < ActiveRecord::Base
  belongs_to :heat, class_name: 'ContestHeat'
  belongs_to :entity
end

class ContestHeat < ActiveRecord::Base
  has_many :heat_entities, foreign_key: 'heat_id'
  has_many :entities, through: :heat_entities
  belongs_to :round, class_name: 'ContestRound'
end
** deploy
*** http://blog.codeclimate.com/blog/2013/10/02/high-speed-rails-deploys-with-git
deploy:update_code — Resets the Git working directory to the latest code we want to deploy.
bundle:install:if_changed — Checks if either the Gemfile or Gemfile.lock were changed, and if so invokes the bundle:install task. Most deploys don’t include Gemfile changes so this saves some time.
assets:precompile:if_changed — Similar to the above, this invokes the assets:precompile task if and only if there were changes that may necessitate asset updates. We look for changes to three paths: app/assets, Gemfile.lock, and config. Asset pre-compilation is notoriously slow, and this saves us a lot of time when pushing out changes that only touch Ruby code or configuration.
deploy:tag — Creates a Git tag on the app server for the release. We never push these tags upstream to GitHub.
deploy:restart — This part varies depending on your application server of choice. For us, we use God to send a USR2 signal to our Unicorn master process.
deploy:verify — This is the most complex part. The simplest approach would have Capistrano wait until the Unicorn processes reboot (with a timeout). However, since Unicorn reboots take 30 seconds, I didn’t want to wait all that extra time just to confirm something that works 99% of the time. Using every ounce of Unix-fu I could muster, I cobbled together a solution using the at utility:
echo 'curl -sS http://127.0.0.1:3000/system/revision | grep "c7fe01a813" > /dev/null || echo "Expected SHA: c7fe01a813" | mail -s "Unicorn restart failed" ops@example.com' | at now + 2 minutes

** jsonp
*** 实例
- render json: ContestsIndexJson << {cated_contests: cated_contests}, callback: params[:callback]
** validates
- 参考: http://api.rubyonrails.org/classes/ActiveModel/Validations/ClassMethods.html
*** normal use
validates :terms, acceptance: true
validates :password, confirmation: true
validates :username, exclusion: { in: %w(admin superuser) }
validates :email, format: { with: /\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\Z/i, on: :create }
validates :age, inclusion: { in: 0..9 }
validates :first_name, length: { maximum: 30 }
validates :age, numericality: true
validates :username, presence: true
validates :username, uniqueness: true

validates :email, format: /@/
validates :gender, inclusion: %w(male female)
validates :password, length: 6..20

*** custome validator
class EmailValidator < ActiveModel::EachValidator
  def validate_each(record, attribute, value)
    record.errors.add attribute, (options[:message] || "is not an email") unless
      value =~ /\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\z/
  end
end

class Person
  include ActiveModel::Validations
  attr_accessor :name, :email

  validates :name, presence: true, uniqueness: true, length: { maximum: 100 }
  validates :email, presence: true, email: true
end

*** 带条件的验证
validates :password, presence: true, confirmation: true, if: :password_required?
validates :token, uniqueness: true, strict: TokenGenerationException
validates :password, presence: { if: :password_required?, message: 'is forgotten.' }, confirmation: true

*** 实例
validates :name, presence: true, uniqueness: true
validates :email, format: /@/, if: ->(sponsor) { sponsor.email.present? }

validates :email, presence: {if: ->(user){ user.email.nil?} }, uniqueness: true
validates :mobile, presence: {if: ->(user){ user.mobile.nil?} }, uniqueness: true  

  validates :email,
  presence: {if: ->(user){ user.mobile.nil?} },
  uniqueness: {if: ->(user){user.email.present?}},
  if: ->(user){ not user.created_ref == UserCreatedRef['后台赞助商'].code}
      
  validates :mobile,
  presence: {if: ->(user){ user.email.nil?} },
  uniqueness: {if: ->(user){user.mobile.present?}},
  if: ->(user){ not user.created_ref == UserCreatedRef['后台赞助商'].code}

** associations
- 参考: http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html
*** 自动生成的方法
Singular associations (one-to-one)

                                  |            |  belongs_to  |
generated methods                 | belongs_to | :polymorphic | has_one
----------------------------------+------------+--------------+---------
other                             |     X      |      X       |    X
other=(other)                     |     X      |      X       |    X
build_other(attributes={})        |     X      |              |    X
create_other(attributes={})       |     X      |              |    X
create_other!(attributes={})      |     X      |              |    X
Collection associations (one-to-many / many-to-many)

                                  |       |          | has_many
generated methods                 | habtm | has_many | :through
----------------------------------+-------+----------+----------
others                            |   X   |    X     |    X
others=(other,other,...)          |   X   |    X     |    X
other_ids                         |   X   |    X     |    X
other_ids=(id,id,...)             |   X   |    X     |    X
others<<                          |   X   |    X     |    X
others.push                       |   X   |    X     |    X
others.concat                     |   X   |    X     |    X
others.build(attributes={})       |   X   |    X     |    X
others.create(attributes={})      |   X   |    X     |    X
others.create!(attributes={})     |   X   |    X     |    X
others.size                       |   X   |    X     |    X
others.length                     |   X   |    X     |    X
others.count                      |   X   |    X     |    X
others.sum(*args)                 |   X   |    X     |    X
others.empty?                     |   X   |    X     |    X
others.clear                      |   X   |    X     |    X
others.delete(other,other,...)    |   X   |    X     |    X
others.delete_all                 |   X   |    X     |    X
others.destroy(other,other,...)   |   X   |    X     |    X
others.destroy_all                |   X   |    X     |    X
others.find(*args)                |   X   |    X     |    X
others.exists?                    |   X   |    X     |    X
others.distinct                   |   X   |    X     |    X
others.uniq                       |   X   |    X     |    X
others.reset                      |   X   |    X     |    X

*** 实际例子
sponsor.create_user(name: name,
		email: email,
		created_ref: UserCreatedRef['后台赞助商'].code
		)
sponsor.save

** validate errors
- ActiveRecord对象的错误模型类似下面:

user.errors #=>
#<ActiveModel::Errors:0x007f8fe8288370
 @base=
  #<User id: nil, name: nil, birthday: nil, gender: nil, mobile: nil, email: nil, avatar: nil, password_hash: nil, password_salt: nil, sn: nil, status: nil, level: 1, point_count: 0, vote_count: 0, created_at: nil, updated_at: nil, marry: 0, location: nil, role: "user", created_ref: 0>,
 @messages=
  {:email=>["can't be blank", "has already been taken"],
   :mobile=>["can't be blank", "has already been taken"]}>


user.errors.messages #=>
{:email=>["can't be blank", "has already been taken"],
 :mobile=>["can't be blank", "has already been taken"]}

user.errors.sort  #=>
[[:email, "can't be blank"],
 [:email, "has already been taken"],
 [:mobile, "can't be blank"],
 [:mobile, "has already been taken"]]

user.errors.to_a #=>
["Email can't be blank",
 "Email has already been taken",
 "Mobile can't be blank",
 "Mobile has already been taken"]
 
user.errors.keys #=>
[:email, :mobile]

** 用户，关注，粉丝的三者关系的在activerecord中的快速实现
*** 表结构
follows
Column       | Type     | Modifiers | Comment 
------------ | -------- | --------- | --------
following_id | integer  |           |  被关注者的id
follower_id  | integer  |           |  关注者的id 
created_at   | datetime |           |         
updated_at   | datetime |           |         

users
Column        | Type     | Modifiers    | Comment                                                                                                
------------- | -------- | ------------ |------------------
id            | integer  |              |
sn            | string   |              |                                                                                                        
gender        | integer  |              |  性别, 0 女, 1 男 

*** 模型
class Follow < ActiveRecord::Base
  belongs_to :following, class_name: 'User'
  belongs_to :follower, class_name: 'User'
end

class User < ActivieRecord::Base

  # 有许多偶像
  has_many :following_relationships, class_name: 'Follow', foreign_key: 'follower_id'
  has_many :followings, through: :following_relationships

  # 有许多粉丝
  has_many :follower_relationships, class_name: 'Follow', foreign_key: 'following_id'
  has_many :followers, through: :follower_relationships

end

** save without validate
user.save(validate: false)
