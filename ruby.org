* Ruby
** md5
require 'digest'
Digest::MD5.hexdigest 'test'

** fiber
- http://www.rubyinside.com/ruby-fibers-8-useful-reads-on-rubys-new-concurrency-feature-1769.html

** 博客
http://tonyarcieri.com
http://clean-ruby.com
** gem升级到特定版本
gem update --system 1.3.7
** Rspec cheat
*** 断言
blog_post.should_not be_published
blog_post.should_not be_nil
*** 初始化变量
let(:mobile_no){'13910655615'}
*** 资源
http://pure-rspec-rubynation.heroku.com/
*** describe和context
alias :context :describe
describe is for your methods
context is for ... contexts

** 并发编程
file:///Users/kkjgm/Documents/Pragmatic%20Concurrency%20With%20Ruby%20-%20Paracode.html
** Public, Protected, Private 方法
file:///Users/kkjgm/Documents/protected-methods-and-ruby-2-0.html

** 邮箱验证
file:///Users/kkjgm/Documents/Stop%20Validating%20Email%20Addresses%20With%20Your%20Complex%20Regex%20-%20davidcelis.com.html
class User < ActiveRecord::Base
  validates_format_of :email, :with => /@/
end

** Gem
*** piece_pipe
code: https://github.com/atomicobject/piece_pipe
file:///Users/kkjgm/Documents/PiecePipe%20Examples_%20Map,%20Aggregation,%20&%20Group-By%20|%20Atomic%20Spin.html
*** SimpleForm
*** rubysh
*** schema_plus
*** letsrate
** Project
*** hobo
** bundle
bundle install --binstubs
*** 错误处理
ERROR: Gem bundler is not installed, run `gem install bundler` first.
如果已经安装了bundle
那么试试rvm use defalut
** 错误处理
在mac mountian lion系统上 gem install json -v '1.7.5' 时报make: /usr/bin/gcc-4.2: No such file or directory的错误
解决方法 sudo ln -s /usr/bin/gcc /usr/bin/gcc-4.2

** Ruby Magic
参考:https://speakerdeck.com/u/jeg2/p/10-things-you-didnt-know-ruby-could-do?utm_source=rubyweekly&utm_medium=email
https://speakerdeck.com/u/jeg2/
*** case on lambda
require 'prime
n = rand(1..10)
p n

case n
when lambda(&:prime?)
  puts "This number is prime"
when lambda(&:even?)
  puts "This number is even"
else
  puts "This number is odd"
end

*** case on ranges
age = rand(1..100)
p age

case age
when -Float::INFINITY
  puts "You'r too young"
when 21..64
  puts "You are the right age"
when 65..Float::INFINITY
  puts "You're too old"
end  

*** inject() a Symbol
   p (1..10).inject(:*)
*** Symbol#to_proc Takes Arguments
to_s_proc = :to_s.to_proc
receiver = 255
arg = 16
puts to_s_proc[receiver, arg]

*** Call Anything Syntax
class Callable
  def call
    :my_own_class
  end
end

p -> {:lambda}.()
p [].method(:class).()
p Callable.new.()

*** Blocks Take Blocks
var = :var
object = Object.new

object.define_singleton_method(:show_var_and_block) do |&block|
  p [var, block]
end

object.show_var_and_block {:block}

*** Lambda 语法
minimal = -> {p :called}
minimal.call

loaded = ->(arg, default = :defaul, &block) { p [arg, default, block]}
loaded.call(:arg) {:block}

*** Pass No Block Up
class Parent
  def show_block(&block)
    p block
  end
end

class Children
  def show_block
    super(&nil)
  end
end

Child.new.show_block {:block}

*** Pass No Args Up
class Parent
  def show_args(*args)
    p args
  end
end

class Children
  def show_args(a, b, c)
    super()
  end
end

Children.new.show_args(:a, :b, :c)

*** A Formatted Output Syntax
def debug(name, content)
  puts "%s: %p" % [name, content]
end

debug "Num", 42
debug "Objects", {"Grays" => %w[James Dana Summer]}


*** Shortcut Variable Interpolation
@instance = :instance
@@class = :class
$global = :global

puts "#@instance, #@@class, and #$global variables don't need braces"

*** Variables From a Regex
if /\A(?<last>\w+, \s*(?<first>\w+))\z/ =~ "Gray, James"
  puts "#{first} #{last}"
end

*** The Unused Variable
{:a => 'b', :c => 'd'}.each {|k, _| p k}
*** Objects Can Contain Themselves
ring = [:one, [:tow, [:three]]]
ring.last.last << ring

ring = %w[one two three].cycle

*** Autovivification
deep = Hash.new {|hash, key| hash[key] = Hash.new(&hash.default_proc)}
deep[:a][:b][:c] = 42

*** Replace Ugly inject() calls
object = (1..3).each_with_object({}) do |n, hash|
  hash[n] = true
end

*** A Smarter loop()
animals = %w[cat bat rat]
enum = animals.to_enum
loop do
  puts "Processing #{enum.next}..."
end

*** Easiest Database
require 'pstore'
require 'yaml/store'

** 好的博客
http://patshaughnessy.net

** yaml
http://www.yaml.org/YAML_for_ruby.html#simple_sequence
*** yaml加载配置文件
YAML.load_file(config_file)[environment]
** rake
*** run tasks from within rake tasks
参考: http://stackoverflow.com/questions/577944/how-to-run-rake-tasks-from-within-rake-tasks
实际应用
  desc '统计所有追号状况'
  task :stat_all_zhuihao, [:num] => [:environment] do |t, args|
    Rake::Task['staging:stat_zhuihao'].reenable
    Rake::Task['staging:stat_zhuihao'].invoke('排列三[组三]', args['num'])
  end
  
*** use argument in rake task
- 参考: http://robots.thoughtbot.com/post/18129303042/how-to-use-arguments-in-a-rake-task
- 参考: https://github.com/robbyrussell/oh-my-zsh/issues/433
namespace :tweets do
  desc 'Send some tweets to a user'
  task :send, [:username] => [:environment] do |t, args|
    Tweet.send(args[:username])
  end
end
rake tweets:send[cpytel]
使用zsh时会报zsh: no matches found: tweets:send[cpytel]的错误
- 解决办法
rake tweets:send\[cpytel\]
or
rake 'tweets:send[cpytel]'
or 
Add alias rake='noglob rake' in your .zshrc
** 用rvm升级ruby
参考: http://stackoverflow.com/questions/3360277/how-do-i-update-ruby-interpreters-with-rvm
rvm upgrade 1.9.2-preview1 1.9.2-rc1
实例
rvm upgrade 1.9.3-p286 1.9.3-p327 --verify-downloads 1
** passenger
passenger start --max-pool-size 10 -S /srv/rorapps/fgcc/tmp/sockets/rails.socket -e development --pid-file /srv/rorapps/fgcc/tmp/pids/passenger.pid -d
passenger stop --pid-file /srv/rorapps/fgcc/tmp/pids/passenger.pid

** refining
代码示例:
module Camelize
  refine String do
    def camelize
      dup.gsub(/_([a-z])/) { $1.upcase }
    end
  end
end

class Foo
  using Camelize

  def camelize_string(str)
    str.camelize
  end
end

** 数字精确到几位小数
1.234567.round(2)  #=> 1.23
'%5.2f' % 123.593  #=> '123.59'

** 大段字符串
   <<-EOF
     <?xml version="1.0" encoding="utf-8" ?>
     <Response>
      <UserID>magus-tester</UserID>
      <OrderNo>abcde1234</OrderNo>
      <Money>20</Money>
      <Result>1</Result>
      <ErrCode>000</ErrCode>
   </Response>
  EOF   

** DSL
treetop

** DCI
** 常用的文件加载技巧
require File.expand_path(File.dirname(__FILE__) + '/spec_helper')   
** 动态定义方法
1. 支持1.9
define_method :m do |a = false|
end

2. 1.8， 1.9
class_eval <<-EVAL
  def #{"m"}(a = false)
  end
EVAL

3. 1.8， 1.9
define_method :m do |*args|
  a = args.first
end

** String Format
"%02d" % 3 #=> '03'
"%0.2f" % 2 #=> '2.00'
** Hash
name, nickname = details[:info].values_at(:name, :nickname)

** Ruby 2.0
*** install
brew update
brew install libyaml
rvm install ruby-2.0.0-rc1
rvm use ruby-2.0.0-rc1
*** Changes
1.Keyword Arguments
def config(enabled: true, timeout: 30)
  [enabled, timeout]
end

def config(value, enabled: true, timeout: 300, **other)
  [value, enabled, timeout, **other]
end

2.prepend

module Foo
  def baz
    'foo-baz'
  end
end

class Bar
  prepend Foo
  def baz
    'bar-baz'
  end
end

Bar.new.baz
#=> 'foo-baz'

3.Enumerable#lazy
arr = [1,2,3,4,5].select {|n| n > 2}
#=> <#:select>
arr.force

4.use %i or %I for symbol list creation
%i{this is a list of symbols}
#=> [:this, :is, :a, :list, :of, :symbols]

** 部署
*** mina
site: http://nadarei.co/mina/
*** vlad
site: http://rubyhitsquad.com/

** Gem
*** kaminari
site: https://github.com/amatsuda/kaminari    

** Proc
Just a small addition to the standard library:

class Regexp
  def to_proc; lambda {|s| self =~ s} end
end

With that one can use a Regex everywhere a Proc is used as filtering criteria saving a bit of typing.  While we have Enumerable#grep already there may be other cases where you want to do something like

irb(main):008:0> %w{foo bar baz}.select &/\Ab/
=> ["bar", "baz"]
irb(main):009:0> %w{foo bar baz}.reject &/\Ab/
=> ["foo"]
irb(main):010:0> %w{foo bar baz}.find &/\Ab/
=> "bar"
** Ruby Issue
http://bugs.ruby-lang.org

** 编码
- http://blog.grayproductions.net/articles/understanding_m17n
** 搭建blog的gem
***  Middleman
** Ruby2.0学习资料
http://globaldev.co.uk/2013/03/ruby-2-0-0-in-detail/
** and 和 &&的区别
a = true && false 等价于 (a = (true && false))
a = true and false 等价于 ((a = true) and false)

** 生成随机字母
('a'..'z').to_a.shuffle[0..7].join
[*?a..?z].sample(8).join
('a'..'z').to_a.sample(8).join
[*('a'..'z')].sample(8).join

** API
- http://overapi.com/

** Memoize Methods
module Memoize

  def memoize(method)
    # Create an anonymous module
    memoizer = Module.new do

      # Define a method in the module with the same name
      define_method method do
        # Ensure we have a place to store the result in
        # case we memoize multiple methods
        @__memoized_results ||= {}

        if @__memoized_results.include? method
          # If we've already calculated the result of
          # this function, return it
          @__memoized_results[method]
        else
          # Otherwise calculate the result by calling
          # the original implementation and store it for
          # future calls
          @__memoized_results[method] = super()
        end
      end

    end

    # Prepend the anonymous module to the class so that
    # its method is called first
    prepend memoizer
  end

end

** 44行的测试框架
module Kernel
  def describe(description, &block)
    tests = Dsl.new.parse(description, block)
    tests.execute
  end
end
class Object
  def should
    self
  end
end
class Dsl
  def initialize
    @tests = {}
  end
  def parse(description, block)
    self.instance_eval(&block)
    Executor.new(description, @tests)
  end
  def it(description, &block)
    @tests[description] = block
  end
end
class Executor
  def initialize(description, tests)
    @description = description
    @tests = tests
    @success_count = 0
    @failure_count = 0
  end
  def execute
    puts "#{@description}"
    @tests.each_pair do |name, block|
      print " - #{name}"
      result = self.instance_eval(&block)
      result ? @success_count += 1 : @failure_count += 1
      puts result ? " SUCCESS" : " FAILURE"
    end
    summary
  end
  def summary
    puts "\n#{@tests.keys.size} tests, #{@success_count} success, #{@failure_count} failure"
  end
end

** Proc, block and 匿名函数
- http://augustl.com/blog/2008/procs_blocks_and_anonymous_functions/
- proc和lambda的区别
def foo
  f = Proc.new { return "return from foo from inside proc" }
  f.call # control leaves foo here
  return "return from foo" 
end

def bar
  f = lambda { return "return from lambda" }
  f.call # control does not leave bar here
  return "return from bar" 
end
- http://www.robertsosinski.com/2008/12/21/understanding-ruby-blocks-procs-and-lambdas/

** 调用外部接口的重试
  # MsBt.try('调用支付宝接口', :max_times => 2, :on => [Net::HTTPBadResponse, Timeout::Error]) do
  #   open(url)
  # end
  def try(title, options = { }, &p)
    tried_times = 0
    max_times = options[:max_times] || 3
    exceptions = options[:on] || Exception
    exceptions = [exceptions] if !exceptions.is_a?(Array)
    rescue_text = <<-EOF
      begin
        # 此处不能用yield
        p.call
      rescue #{exceptions.join(',')} => e
        log_exception(title, e)
        retry if (tried_times += 1) < max_times
        raise e
      end
    EOF
    eval rescue_text
  end

** 发送邮件
http://apidock.com/ruby/Net/SMTP
** 数据库备份脚本
#!/srv/ruby19/bin/ruby
# encoding: UTF-8
require 'rubygems'
require 'active_record'
require 'pg'
require 'fileutils'

=begin
2012-09-19
PostgreSQL 数据库备份脚本
每次执行都备份到指定的目录下
每个数据库一个文件，扩展名是 dump
恢复需要先建立数据库，然后 pg_restore 进行恢复
=end
#配置开始
ActiveRecord::Base.establish_connection(
  :adapter=>"postgresql",
  :database => 'template1',
  :host => 'localhost',
  :port => 5432,
  :username => 'pgsql',
  :password => 'none'
)
#不做备份处理的数据库
SKIP_DATABASES = %w(template0 template1 sandbox fgpay2_test)
#备份存放的目录
BACKUP_BASE_DIR = "/srv/pg_backup/#{Time.now.to_s(:number)}"
puts "备份目的路径: #{BACKUP_BASE_DIR}"
FileUtils.mkdir_p(BACKUP_BASE_DIR) unless File.exists?(BACKUP_BASE_DIR)
PG_BIN = "<pgsql bin路径>"

#配置结束
#获取所有的数据库列表
class PgDatabase < ActiveRecord::Base
  self.table_name = "pg_database"
  def self.all_databases
    select('datname').where(["datistemplate = false"]).map{|record|
    record.try(:datname) unless SKIP_DATABASES.include?(record.try(:datname)) }.delete_if{|r| r.blank?}
  end
end

pg_dump_bin = lambda{|db_name|
  #c模式 --clean --create 无效
  system("#{PG_BIN}/pg_dump -Upgsql --blobs  --format=c --compress=9 --file=#{BACKUP_BASE_DIR}/#{db_name}.dump #{db_name}")
}

puts PgDatabase.all_databases.each{|db_name|
  puts "BEGIN BackUp #{db_name} "
  pg_dump_bin.call(db_name)
  puts "BackUp #{db_name} done.\n\n"
}

** 解决字符编码的异常
menu.to_s.encode('UTF-8', {:invalid => :replace, :undef => :replace, :replace => '?'})

** binding
- http://onestepback.org/index.cgi/Tech/Ruby/RubyBindings.rdoc   
def value_of_a(vars)
  eval "a", vars
end

def my_scope
  a = 33
  value_of_a(binding)
end

a = 1
def my_scope(b)
  a = 33
  value_of_a(b)
end

my_scope(binding)

** new gem with bundle
- http://asciicasts.com/episodes/245-new-gem-with-bundler
** make your own gem
- http://guides.rubygems.org/make-your-own-gem/
- 基本结构
% tree
.
├── hola.gemspec
└── lib
    └── hola.rb
- gemspec
Gem::Specification.new do |s|
  s.name        = 'hola'
  s.version     = '0.0.0'
  s.date        = '2010-04-28'
  s.summary     = "Hola!"
  s.description = "A simple hello world gem"
  s.authors     = ["Nick Quaranto"]
  s.email       = 'nick@quaran.to'
  s.files       = ["lib/hola.rb"]
  s.homepage    = 'http://rubygems.org/gems/hola'
  s.license     = 'MIT'
end

- build
gem build hola.gemspec

- push to rubygems.org
gem push hola-0.0.0.gem

** rake test
require 'rake/testtask'
Rake::TestTask.new do |t|
  t.libs << 'test'
  t.test_files = FileList['test/*_test.rb']
  t.verbose = true
end

desc "Run tests"
task :default => :test

** detect base64 encode image content type
- http://stackoverflow.com/questions/6955950/retrieve-filename-and-content-type-from-base64-encoded-image-ruby-on-rails
require 'rmagick'
bytes = ActiveSupport::Base64.decode64(params[:image])
img   = RMagick::Image.from_blob(bytes).first
fmt   = img.format

** How to add rmagick to Gemfile in ubuntu server?
gem "rmagick", :require => 'RMagick'
如果写成
gem "rmagick"
那么即使安装rmagick成功后，rails也会抱怨找不到rmagick

** 构建自己的console
- 参考 http://ruby-china.org/topics/13337
require 'irb'
require 'irb/completion'
IRB.start

** 漂亮打印 pp
一段几乎不可读的s-expression表达式经过pp打印后就变得可读了
s(:class,
 :CreateContests,
 s(:colon2, s(:const, :ActiveRecord), :Migration),
 s(:defn,
  :change,
  s(:args),
  s(:iter,
   s(:call, nil, :create_table, s(:lit, :contests)),
   s(:args, :t),
   s(:block,
    s(:call, s(:lvar, :t), :string, s(:lit, :sn)),
    s(:call, s(:lvar, :t), :string, s(:lit, :title)),
    s(:call, s(:lvar, :t), :text, s(:lit, :description)),
    s(:call,
     s(:lvar, :t),
     :integer,
     s(:lit, :itype),
     s(:hash, s(:lit, :default), s(:lit, 0), s(:lit, :null), s(:false))),
    s(:call,
     s(:lvar, :t),
     :integer,
     s(:lit, :mode),
     s(:hash, s(:lit, :default), s(:lit, 0), s(:lit, :null), s(:false))),
    s(:call,
     s(:lvar, :t),
     :integer,
     s(:lit, :format),
     s(:hash, s(:lit, :default), s(:lit, 0), s(:lit, :null), s(:false))),
    s(:call, s(:lvar, :t), :date, s(:lit, :start_day)),
    s(:call, s(:lvar, :t), :integer, s(:lit, :length)),
    s(:call, s(:lvar, :t), :integer, s(:lit, :vote_right)),
    s(:call, s(:lvar, :t), :integer, s(:lit, :contestant_right)),
    s(:call, s(:lvar, :t), :string, s(:lit, :logo)),
    s(:call,
     s(:lvar, :t),
     :integer,
     s(:lit, :prize_status),
     s(:hash, s(:lit, :default), s(:lit, 0))),
    s(:call, s(:lvar, :t), :integer, s(:lit, :user_id)),
    s(:call, s(:lvar, :t), :string, s(:lit, :user_sn)),
    s(:call,
     s(:lvar, :t),
     :integer,
     s(:lit, :kind),
     s(:hash, s(:lit, :default), s(:lit, 0))),
    s(:call,
     s(:lvar, :t),
     :integer,
     s(:lit, :view_count),
     s(:hash, s(:lit, :default), s(:lit, 0))),
    s(:call,
     s(:lvar, :t),
     :integer,
     s(:lit, :join_count),
     s(:hash, s(:lit, :default), s(:lit, 0))),
    s(:call, s(:lvar, :t), :timestamps)))))

** alias for restart unicorn
- alias kill2='kill -USR2 `cat tmp/pids/unicorn.pid`'
** command option parse
class ParseCommandOptions < Dun::Activity

  data_reader :args

  def call
    options = {}
    opt_parser = OptionParser.new do |opts|
      
      opts.on("-m", "--migrations DIR", "specify migration file dir") {|dir|
        options[:migration_dir] = dir
      }

      options[:port] = '9393'
      opts.on("-p", "--port PORT", "use PORT (default: 9393)") {|port|
        options[:port] = port
      }

      opts.on("-s", "--server SERVER", "server using SERVER") {|server|
        options[:server] = server
      }
      
    end

    opt_parser.parse! args

    options
    
  end
  
end
- http://ruby.about.com/od/advancedruby/a/optionparser2.htm

** ruby元编程学习资料
- http://ruby-china.org/wiki/ruby-meta

** 判断文件是否存在
- File.file? filname, 只能判断文件，不能判断文件夹
- File.exists? filename

** ruby vm学习资料
- http://edwinmeyer.com/Integrated_RHG.html
** gsub
- 'John  Wayne'.gsub(/\w+\s+(\w+)/, 'Bruce \1')   # "Bruce Wayne"
- 'Apollo 12'.gsub(/\d+/) { |num| num.to_i.next } # "Apollo 13"
- 'Apollo 12'.gsub(/(\d+)/) { Regexp.last_match[1].to_i.next } # 'Apollo 13'
- 'Apollo 12'.gsub(/(\w+) (\d+)/) { |name, number| puts name, number }

** 可读性好的大数字
- 10_000_000_000
- 0.2_343_434_343
- BIT_MASK = 0b1001_0101_0101

** sequel
*** migration command
- 参考: http://sequel.rubyforge.org/rdoc/files/doc/migration_rdoc.html
- 参考: http://sequel.rubyforge.org/rdoc/classes/Sequel/Migrator.html
sequel -m path/to/migrations postgres://host/database

# Migrate all the way down
sequel -m db/migrations -M 0 postgres://host/database
# Migrate to version 10 (IntegerMigrator style migrations)
sequel -m db/migrations -M 10 postgres://host/database

# Migrate to version 20100510 (TimestampMigrator migrations using YYYYMMDD)
sequel -m db/migrations -M 20100510 postgres://host/database

Sequel::Migrator.run(DB, "migrations")
Sequel::Migrator.run(DB, "migrations", :target=>15, :current=>10)
Sequel::Migrator.run(DB, "app1/migrations", :column=> :app2_version)
Sequel::Migrator.run(DB, "app2/migrations", :column => :app2_version, :table=>:schema_info2)

*** column types
- 参考: bhttp://sequel.rubyforge.org/rdoc/files/doc/schema_modification_rdoc.html
create_table(:columns_types) do       # common database type used
  Integer :a0                         # integer
  String :a1                          # varchar(255)
  String :a2, :size=>50               # varchar(50)
  String :a3, :fixed=>true            # char(255)
  String :a4, :fixed=>true, :size=>50 # char(50)
  String :a5, :text=>true             # text
  File :b,                            # blob
  Fixnum :c                           # integer
  Bignum :d                           # bigint
  Float :e                            # double precision
  BigDecimal :f                       # numeric
  BigDecimal :f2, :size=>10           # numeric(10)
  BigDecimal :f3, :size=>[10, 2]      # numeric(10, 2)
  Date :g                             # date
  DateTime :h                         # timestamp
  Time :i                             # timestamp
  Time :i2, :only_time=>true          # time
  Numeric :j                          # numeric
  TrueClass :k                        # boolean
  FalseClass :l                       # boolean
end

*** data set
- 参考: http://sequel.rubyforge.org/rdoc/classes/Sequel/Dataset.html
*** add index
- 参考: http://sequel.rubyforge.org/rdoc/files/doc/schema_modification_rdoc.html
alter_table(:albums) do
  add_index :artist_id
end
****实例:
Sequel.migration do
  up do
    alter_table(:stars) do
      add_index :source_id
      add_index :name
      add_index :description
    end

    alter_table(:reindex_stars) do
      add_index :status
    end

    alter_table(:q_star_assocs) do
      add_index :q
      add_index :star_id
      add_index :score
      add_index [:q, :star_id]
    end

    alter_table(:dic_stars) do
      add_index :star_id
      add_index :dic_id
    end

    alter_table(:dics) do
      add_index :word
    end
    
  end

  down do
    alter_table(:stars) do
      drop_index :source_id
      drop_index :name
      drop_index :description
    end

    alter_table(:reindex_stars) do
      drop_index :status
    end

    alter_table(:q_star_assocs) do
      drop_index :q
      drop_index :star_id
      drop_index :score
      drop_index [:q, :star_id]
    end

    alter_table(:dic_stars) do
      drop_index :star_id
      drop_index :dic_id
    end

    alter_table(:dics) do
      drop_index :word
    end
    
  end
end

** scan
*** 汉字
"我们的生活".scan(/\w/mu) #=> %w(我 们 的 生 活)
** 正则
*** 匹配汉字
- 参考: http://www.ruby-doc.org/core-1.9.3/Regexp.html 
- 参考: http://ruby-china.org/topics/5680
- "word cool 我们的生活".scan(/\p{Han}+|\w+/)
- "word cool 我们的生活 走去".scan(/\p{Han}+|\w+/)
** 生成ruby ri doc
- rvm docs generate

** 后台任务 cron
*** whenever http://github.com/javan/whenever
- 实例

set :output, File.join(File.expand_path(File.dirname(__FILE__)), '../', 'log', "cron_log.log")
set :output, File.expand_path(File.join(File.dirname(__FILE__), '../', 'log', "cron_log.log"))

every 1.minute do
  rake "cron:heats"
end

whenever --set 'environment=development' --update-crontab

不加--update-conrtab选项的话，仅仅查看生成的crontab语法
whenever --set 'environment=development' 

** tempfile
- good practice
require 'tempfile'

file = Tempfile.new('foo')
file.path      # => A unique filename in the OS's temp directory,
               #    e.g.: "/tmp/foo.24722.0"
               #    This filename contains 'foo' in its basename.
file.write("hello world")
file.rewind
file.read      # => "hello world"
file.close
file.unlink    # deletes the temp file
- 参考 http://www.ruby-doc.org/stdlib-1.9.3/libdoc/tempfile/rdoc/Tempfile.html#documentation
** whenever
*** "\xE8" on US-ASCII 错误
开始的配置
every 1.minutes do
  rake "cron:check_latest_stars --trace"
end
报"\xE8" on US-ASCII错误
google到原因 http://www.logikdev.com/2010/02/02/locale-settings-for-your-cron-job/
后改成,
job_type :rake_utf8, "export LANG=zh_CN.UTF-8 && cd :path && :environment_variable=:environment bundle exec rake :task --silent :output"
every 1.minutes do
  rake_utf8 "cron:check_latest_stars --trace"
end

** delayed_job
*** 实例1
- gem 'delayed_job_active_record'
- bin/rails generate delayed_job:active_record
- RAILS_ENV=production bin/rake db:migrate
- RAILS_ENV=production script/delayed_job start
- RAILS_ENV=production script/delayed_job stop

** lambda case
***lambdas slash procs in case expressions:  http://batsov.com/articles/2013/09/24/lambdas-slash-procs-in-case-expressions/
is_even = ->(n) { n.even? }

is_even === 5 # => false

# same as
is_even.call(5)

def even?
  ->(n) { n.even? }
end

def odd?
  ->(n) { n.odd? }
end

case x
when even? then puts 'even'
when odd? then puts 'odd'
else puts 'zero'
end

case x
when ->(n) { n.even? } then puts 'even'
when ->(n) { n.odd? } then puts 'odd'
else puts 'zero'
end

def response_code?(code)
  ->(response) { response.code == code }
end

case response
when response_code?(200) then 'OK'
when response_code?(404) then 'Not found'
else 'Unknown code'
end

** lambda invoke way
- 参考: http://batsov.com/articles/2013/09/26/the-elements-of-style-in-ruby-number-11-invoking-lambdas-slash-procs/
lambda.call(arg1, arg2)

lambda[arg1, arg2]

lambda.(arg1, arg2)

# works only with one argument lambdas
lambda === arg

** sprintf
- 参考:http://batsov.com/articles/2013/06/27/the-elements-of-style-in-ruby-number-2-favor-sprintf-format-over-string-number-percent/
'%d %d' % [20, 10]
# => '20 10'

sprintf('%d %d', 20, 10)
# => '20 10'

'%d' % 20
# => '20'

'%d %d' % [20, 10]
# => '20 10'

sprintf('%d %d', 20)
# => '20'

sprintf('%d %d', 20, 10)

# a and b are variables
a % b
** Special global variables
- $:, $;, $!, $$, $\
$:.unshift File.dirname(__FILE__)
files = `git ls-files`.split($\)
类似
require 'English'
$LOAD_PATH.unshift File.dirname(__FILE__)
files = `git ls-files`.split($INPUT_RECORD_SEPARATOR)

/(regexp)/ =~ string
...
# this is Perl-style
process $1
# this is the same, but more clear and more object oriented
process Regexp.last_match[1]

** ruby 2.1 preview
*** 参考
- http://spin.atomicobject.com/2013/09/26/ruby-2-1-preview/
- http://ruby-china.org/topics/14327
- http://ruby-china.org/topics/14123
- http://rkh.im/ruby-2.1
1. 后缀语法
r 有理数
i 虚数
f frozen string

0.1r * 3 #=> (3/10)
2. def返回symbol
before_filter def require_login
  ...
end

before_filter \
def require_login
  ...
end

attr_writer def foo
  @foo ||= 'foo'
end

{
  def foo
  end => def bar
          end
}

# only foo and bar will be private
class Foo
  private def foo
  end

  private \
  def bar
  end

  def baz
  end
end

# only foo will be private
class Foo
  def foo
  end

  private :foo

  # bar is not affected
  def bar
  end
end


3. refine
module Foo
  refine String do
    def foo
      self + "foo"
    end
  end
end

using Foo
puts "bar".foo

module Foo
  refine String do
    def foo
      self + "foo"
    end
  end
end

module Bar
  using Foo
  puts "bar".foo
end

4. Required Keyword Arguments

def foo(a: 10)
  puts a
end

foo(a: 20) # 20
foo        # 10

def foo(a:)
  puts a
end

foo(a: 20) # 20
foo        # ArgumentError: missing keyword: a


5. Removing Garbage Bytes from Strings
Ruby now comes with a handy method to remove garbage bytes from strings:
some_string.scrub("")

6. StringScanner supports Named Captures
require 'strscan'
s = StringScanner.new("foo")
s.scan(/(?<bar>.*)/)
puts s[:bar]

7. Accessing Network Interfaces

You can now access the network interfaces via Socket.getifaddrs:
require 'socket'

Socket.getifaddrs.each do |i|
  puts "#{i.name}: #{i.addr.ip_address}" if i.addr.ip?
end
** *args
*** 
def a(*names, opt)
  puts names.inspect
end

a(1,2) #=> [1]

def a(*names, opt=nil)
  puts names.inspect
end

会报语法错误

** daemons
- 参考: https://github.com/rack/rack/blob/1.4.1/lib/rack/server.rb#L309
- 参考: http://daemons.rubyforge.org/classes/Daemons.html
db = <Sequel::SQLite::Database: {"adapter"=>"sqlite", "database"=>"db/development.sqlite3", "pool"=>5, "timeout"=>5000}>
一个rack应用，以rackup启动时(非daemon形式), db可以正常访问
以rackup -D (daemon形式)启动时，db访问出错，通过查看daemon的文档发现，创建一个daemon会做下面的六件事情，其中4是造成db访问错误的原因

1.Forks a child (and exits the parent process, if needed)
2.Becomes a session leader (which detaches the program from the controlling terminal).
3.Forks another child process and exits first child. This prevents the potential of acquiring a controlling terminal.
4.Changes the current working directory to "/".
5.Clears the file creation mask (sets umask to 0000).
6.Closes file descriptors (reopens STDOUT and STDERR to point to a logfile if possible).
** 构建epub
bundle
gem install eeepub
ruby script/publish
** 异常重试
*** 根据特定的异常重试
def net_try(title, options = { }, &p)
 tried_times = 0
 ee = '#{e}'
 etried_times = '#{tried_times}'
 max_times = options[:max_times] || 3
 exceptions = options[:on] || Exception
 exceptions = [exceptions] if not exceptions.is_a?(Array)
 rescue_text = <<-EOF
   begin
     p.call
   rescue #{exceptions.join(',')} => e
    Rails.logger.info("#{title}发生异常#{ee}")
     if (tried_times += 1) < max_times
       Rails.logger.info("开始重试#{title}--第#{etried_times}次重试")
       sleep 10
       retry 
     end
     raise e
   end
 EOF
 eval rescue_text
end
** time strftime
- 参考: http://www.ruby-doc.org/core-2.0.0/Time.html#method-i-strftime

%Y%m%d           => 20071119                  Calendar date (basic)
%F               => 2007-11-19                Calendar date (extended)
%Y-%m            => 2007-11                   Calendar date, reduced accuracy, specific month
%Y               => 2007                      Calendar date, reduced accuracy, specific year
%C               => 20                        Calendar date, reduced accuracy, specific century
%Y%j             => 2007323                   Ordinal date (basic)
%Y-%j            => 2007-323                  Ordinal date (extended)
%GW%V%u          => 2007W471                  Week date (basic)
%G-W%V-%u        => 2007-W47-1                Week date (extended)
%GW%V            => 2007W47                   Week date, reduced accuracy, specific week (basic)
%G-W%V           => 2007-W47                  Week date, reduced accuracy, specific week (extended)
%H%M%S           => 083748                    Local time (basic)
%T               => 08:37:48                  Local time (extended)
%H%M             => 0837                      Local time, reduced accuracy, specific minute (basic)
%H:%M            => 08:37                     Local time, reduced accuracy, specific minute (extended)
%H               => 08                        Local time, reduced accuracy, specific hour
%H%M%S,%L        => 083748,000                Local time with decimal fraction, comma as decimal sign (basic)
%T,%L            => 08:37:48,000              Local time with decimal fraction, comma as decimal sign (extended)
%H%M%S.%L        => 083748.000                Local time with decimal fraction, full stop as decimal sign (basic)
%T.%L            => 08:37:48.000              Local time with decimal fraction, full stop as decimal sign (extended)
%H%M%S%z         => 083748-0600               Local time and the difference from UTC (basic)
%T%:z            => 08:37:48-06:00            Local time and the difference from UTC (extended)
%Y%m%dT%H%M%S%z  => 20071119T083748-0600      Date and time of day for calendar date (basic)
%FT%T%:z         => 2007-11-19T08:37:48-06:00 Date and time of day for calendar date (extended)
%Y%jT%H%M%S%z    => 2007323T083748-0600       Date and time of day for ordinal date (basic)
%Y-%jT%T%:z      => 2007-323T08:37:48-06:00   Date and time of day for ordinal date (extended)
%GW%V%uT%H%M%S%z => 2007W471T083748-0600      Date and time of day for week date (basic)
%G-W%V-%uT%T%:z  => 2007-W47-1T08:37:48-06:00 Date and time of day for week date (extended)
%Y%m%dT%H%M      => 20071119T0837             Calendar date and local time (basic)
%FT%R            => 2007-11-19T08:37          Calendar date and local time (extended)
%Y%jT%H%MZ       => 2007323T0837Z             Ordinal date and UTC of day (basic)
%Y-%jT%RZ        => 2007-323T08:37Z           Ordinal date and UTC of day (extended)
%GW%V%uT%H%M%z   => 2007W471T0837-0600        Week date and local time and difference from UTC (basic)
%G-W%V-%uT%R%:z  => 2007-W47-1T08:37-06:00    Week date and local time and difference from UTC (extended)

** proc魔法
*** http://ruby-china.org/topics/14704
def f
  Module.new &Proc.new
end

M = f do
  def self.x
    'hello world'
  end
end

M.x # => "Hello world"
事实上这个案例可以直接简化成：

def f
  Proc.new
end

(f { |name| 'hello, ' + name }).call 'bachue'
# => "hello, bachue"

** each_with_index
hash = Hash.new
%w(cat dog wombat).each_with_index {|item, index|
  hash[item] = index
}
hash
** crop image
*** mini-magick
- 参考: http://stackoverflow.com/questions/8418973/undefined-method-crop-using-carrierwave-with-minimagick-on-rails-3-1-3
def cropped_image(params)
    image = MiniMagick::Image.open(self.image.path)
    crop_params = "#{params[:w]}x#{params[:h]}+#{params[:x]}+#{params[:y]}"
    image.crop(crop_params)

    image
end

image = RestClient.get 'http://feichanghaokan.com/image/91kCMgQDEzUQNVBUSizYZg.jpg'

class CropImage < Dun::Activity

  data_reader :x, :y, :w, :h, :image

  def call
    image_data = MiniMagick::Image.read image
    crop_params = "#{w}x#{h}+#{x}+#{y}"
    image_data.crop crop_params

    image_data
  end


end

CropImage << {image: image, x: 0, y: 0, w: 100, h: 100}

** 获取文件扩展名
File.extname(filename)
filename.chomp(File.extname(filename))
** search constants
- 参考: http://valve.github.io/blog/2013/10/26/constant-resolution-in-ruby/
*** nesting
module A
  A_CONSTANT = 'I am defined in module A'
  module B
    module C
      def self.inspect_nesting

        puts Module.nesting.inspect
        puts A_CONSTANT
      end
    end
  end
end

A::B::C.inspect_nesting
# => [A::B::C, A::B, A]
# => I am defined in module A

*** Inheritance

class Person
  DRIVING_LICENSE_AGE = 18
end

class BusDriver < Person
  def can_drive_from
    DRIVING_LICENSE_AGE
  end
end

bus_driver = BusDriver.new
puts bus_driver.can_drive_from

*** Mixins

module Insurable
  LIFE_INSURANCE_AMOUNT = 150_000
end

class Person
  DRIVING_LICENSE_AGE = 18
end

class BusDriver < Person
  include Insurable
  def can_drive_from
    "Can drive from #{DRIVING_LICENSE_AGE}, with life insurance of $#{LIFE_INSURANCE_AMOUNT}"
  end
end

puts BusDriver.ancestors.inspect
puts BusDriver.new.can_drive_from

*** Full search path
# searching from left to right
full_path = [Module.nesting + Module.ancestors].uniq

** dsl例子 
- 积分规则
class FchkCredits < Dun::Activity

  data_reader :user

  class << self

    attr_reader :rules

    def add(opts = {})
      rule :add, opts
    end

    def rule(name, opts = {})
      @rules ||= []
      @rules << [name, opts]
    end

  end

  def call
    rules.each {|rule| send rule[0], rule[1] }
    user.save
  end

  private

  def rules
    self.class.rules
  end

  def add(opts = {})
    user.increment(:point_count, opts[:points])
    user.increment(:vote_count, opts[:votes])
  end

end

class FchkCredits
  # 注册普通会员,成功奖励10分，50投票
  class Signup < self
    add points: 10, votes: 50
  end
  
end

** devise
*** 禁止注册后台用户
class AdminAccount < ActiveRecord::Base
  # Include default devise modules. Others available are:
  # :confirmable, :lockable, :timeoutable and :omniauthable, :registerable
  # 不允许注册，去掉:registerable就可以了
  devise :database_authenticatable, :recoverable, :rememberable, :trackable, :validatable
end
*** 手动添加后台用户
- 参考: http://stackoverflow.com/questions/4660565/how-to-manually-create-a-new-user-and-user-session-in-devise
@user = User.new(:email => 'test@example.com', :password => 'password', :password_confirmation => 'password')
@user.save
- 实例:
admin = AdminAccount.new(email: email, password: password, password_confirmation: password)
admin.save

** 在mavericks上安装jeklly失败
** lambda的闭包现象
1.
 aa = 2
 ff = -> {aa = 3}
 puts ff.call  #=> 3
 puts aa       #=> 3

2.
  ff = -> {aa = 3}
  aa = 2
  puts ff.call #=> 3
  puts aa #=> 2

3.

  def ff &p
    p.call
  end

  a = 2

  ff do
    a = 3
  end

  puts a  #=> 3

*** 实例
class PkVoteController < ServiceApiController

  before_filter :find_user, :find_heat

  Test = false

  def create
    voted_entity = Entity.where(sn: params[:voted_entity_sn]).first
    lose_entity = Entity.where(sn: params[:lose_entity_sn]).first
    vote = Vote.new
    
    begin
      transaction do
        vote = CreateVote << {user: @user, entity: voted_entity, heat: @heat}
        RecordJoinContest << {user: @user, contest: voted_entity.contest}

        KeepPkScore << {vote: vote, voted_entity: voted_entity, lose_entity: lose_entity}
        FchkCredits::Vote << {user: @user, entity: voted_entity}
      end

      render json: VoteCreateJson << {
        vote: vote,
        voted_entity: voted_entity,
        lose_entity: lose_entity
      },
      callback: params[:callback]

    rescue FchkCredits::NoEnoughVoteOrCreditError => e
      Rails.logger.info("--捕获异常:--#{e.inspect}--")
      render json: RespJson << {code: -11}, callback: params[:callback]
    end

  end
  
end

** 并行赋值
- 参考: http://ruby-china.org/topics/15526

CSV.foreach("csv_path") do |row|
  title, desc, name ... = row
  # handle title, desc, name
end

CSV.foreach("csv_path") do |(title, desc, name, *rest)|
  # handle title, desc, name
end

_, date, urlname, _ = *filename.match(/\A#{tmp_path}\/_posts\/(\d+-\d+-\d+)-(.+)(\.[^.]+)\z/)

a,b,c,d = *0...4

** push ios and android notifications
- 参考: http://blog.wellwith.me/how-to-send-ios-and-android-notifications-from-your-rails-backend
- 参考: http://blog.csdn.net/lifengzhong/article/details/7737028
- 参考: http://tanqisen.github.io/blog/2013/02/27/ios-push-apns/
*** 检查连接是否正确
openssl s_client -connect gateway.sandbox.push.apple.com:2195 -cert certs/ios/push_development.pem -key certs/ios/push_development.pem 
*** gems
- grocer https://github.com/grocer/grocer
- GCM https://github.com/spacialdb/gcm

*** String upcase, downcase
** unicorn
unicorn_rails -c config/unicorn.rb -D
unicorn_rails -c config/unicorn.rb -D -E staging
** ruby 2.0
- 参考: http://blog.marc-andre.ca/2013/02/23/ruby-2-by-example/
*** __dir__
# Ruby 1.8:
require File.dirname(__FILE__) + "/lib"
File.read(File.dirname(__FILE__) + "/.Gemfile")

# Ruby 1.9:
require_relative 'lib'
File.read(File.dirname(__FILE__) + '/.config')

# Ruby 2.0
require_relative 'lib' # no need to use __dir__ for this!
File.read(__dir__ + '/.config')

*** bsearch
# Ruby 2.0:
ary = [0, 4, 7, 10, 12]
ary.bsearch {|x| x >=   6 } #=> 7
ary.bsearch {|x| x >= 100 } #=> nil

# Also on ranges, including ranges of floats:
(Math::PI * 6 .. Math::PI * 6.5).bsearch{|f| Math.cos(f) <= 0.5}

*** to_h
# Ruby 2.0:
Car = Struct.new(:make, :model, :year) do
  def build
    #...
  end
end
car = Car.new('Toyota', 'Prius', 2014)
car.to_h # => {:make=>"Toyota", :model=>"Prius", :year=>2014}
nil.to_h # => {}



** ruby版本管理工具
- rvm
- rbenv  https://github.com/sstephenson/rbenv
- chruby https://github.com/postmodern/chruby
- rbfu
- ry
- ruby-version
